This is kawa.info, produced by makeinfo version 5.2 from kawa.texi.

START-INFO-DIR-ENTRY
* kawa: (kawa).         The Kawa Scheme language
END-INFO-DIR-ENTRY


File: kawa.info,  Node: Quantities,  Next: Logical Number Operations,  Prev: Quaternions,  Up: Numbers

11.5 Quantities and Units
=========================

As a super-class of numbers, Kawa also provides quantities.  A
"quantity" is a product of a "unit" and a pure number.  The number part
can be an arbitrary complex number.  The unit is a product of integer
powers of base units, such as meter or second.

   Quantity literals have the following syntax:
     QUANTITY ::= OPTIONAL-SIGN DECIMAL UNIT-TERM [â€˜*â€™ UNIT-TERM]... [â€˜/â€™ UNIT-TERM]
     UNIT-TERM ::= UNIT-NAME [â€˜^â€™ DIGIT+]
     UNIT-NAME ::= LETTER+
   Some examples are â€˜10ptâ€™ (10 points), â€˜5sâ€™ (5 seconds), and â€˜4cm^2â€™
(4 square centimeters).

   Note the QUANTITY syntax is not recognized by the reader.  Instead
these are read as symbols.  Assuming there is no lexical binding the for
the symbol, it will be rewritten at compile-time into an expression.
For example â€˜4cm^2â€™ is transformed into:
     (* 4.0 (expt unit:cm 2))

 -- Procedure: quantity? object
     True iff OBJECT is a quantity.  Note that all numbers are
     quantities, but not the other way round.  Currently, there are no
     quantities that re not numbers.  To distinguish a plain unit-less
     number from a quantity, you can use â€˜complex?â€™.

 -- Procedure: quantity->number q
     Returns the pure number part of the quantity Q, relative to
     primitive (base) units.  If Q is a number, returns Q.  If Q is a
     unit, yields the magitude of Q relative to base units.

 -- Procedure: quantity->unit q
     Returns the unit of the quantity Q.  If Q is a number, returns the
     empty unit.

 -- Procedure: make-quantity x unit
     Returns the product of X (a pure number) and UNIT.  You can specify
     a string instead of UNIT, such as â€˜"cm"â€™ or â€˜"s"â€™ (seconds).

 -- Syntax: define-base-unit unit-name dimension
     Define UNIT-NAME as a base (primitive) unit, which is used to
     measure along the specified DIMENSION.
          (define-base-unit dollar "Money")

 -- Syntax: define-unit unit-name expression
     Define UNIT-NAME as a unit (that can be used in literals) equal to
     the quantity EXPRESSION.
          (define-unit cent 0.01dollar)
     The UNIT-NAME is declared in the â€˜unitâ€™ namespace, so the above is
     equivalent to:
          (define-constant unit:cent (* 0.01 unit:dollar))


File: kawa.info,  Node: Logical Number Operations,  Next: Performance of numeric operations,  Prev: Quantities,  Up: Numbers

11.6 Logical Number Operations
==============================

These functions operate on the 2â€™s complement binary representation of
an exact integer.

 -- Procedure: bitwise-not i
     Returns the bit-wise logical inverse of the argument.  More
     formally, returns the exact integer whose twoâ€™s complement
     representation is the oneâ€™s complement of the twoâ€™s complement
     representation of I.

 -- Procedure: bitwise-and i ...
 -- Procedure: bitwise-ior i ...
 -- Procedure: bitwise-xor i ...
     These procedures return the exact integer that is the bit-wise
     â€œandâ€, â€œinclusive orâ€, or â€œexclusive orâ€ of the twoâ€™s complement
     representations of their arguments.  If they are passed only one
     argument, they return that argument.  If they are passed no
     arguments, they return the integer that acts as identity for the
     operation: -1, 0, or 0, respectively.

 -- Procedure: bitwise-if i1 i2 i3

     Returns the exact integer that is the bit-wise â€œifâ€ of the twos
     complement representations of its arguments, i.e.  for each bit, if
     it is 1 in i1, the corresponding bit in i2 becomes the value of the
     corresponding bit in the result, and if it is 0, the corresponding
     bit in i3 becomes the corresponding bit in the value of the result.
     This is equivaent to the following computation:
          (bitwise-ior (bitwise-and i1 i2)
                       (bitwise-and (bitwise-not i1) i3))

 -- Procedure: bitwise-bit-count i
     If ei is non-negative, returns the number of 1 bits in the twos
     complement representation of i.  Otherwise it returns the result of
     the following computation:
          (bitwise-not (bitwise-bit-count (bitwise-not i)))

 -- Procedure: bitwise-length i
     Returns the number of bits needed to represent i if it is positive,
     and the number of bits needed to represent â€˜(bitwise-not I)â€™ if it
     is negative, which is the exact integer that is the result of the
     following computation:
          (do ((result 0 (+ result 1))
               (bits (if (negative? i)
                         (bitwise-not i)
                         ei)
                     (bitwise-arithmetic-shift bits -1)))
              ((zero? bits)
               result))
     This is the number of bits needed to represent I in an unsigned
     field.

 -- Procedure: bitwise-first-bit-set i
     Returns the index of the least significant 1 bit in the twos
     complement representation of i.  If ei is 0, then - 1 is returned.
          (bitwise-first-bit-set 0) â‡’ -1
          (bitwise-first-bit-set 1) â‡’ 0
          (bitwise-first-bit-set -4) â‡’ 2

 -- Procedure: bitwise-bit-set? i1 i2
     Returns â€˜#tâ€™ if the i2â€™th bit (where I2 must be non-negative) is 1
     in the twoâ€™s complement representation of I1, and â€˜#fâ€™ otherwise.
     This is the result of the following computation:
          (not (zero?
                 (bitwise-and
                   (bitwise-arithmetic-shift-left 1 i2)
                   i1)))

 -- Procedure: bitwise-copy-bit i bitno replacement-bit
     Return the result of replacing the BITNOâ€™th bit of I by
     REPLACEMENT-BIT, where BITNO must be non-negative, and
     REPLACEMENT-BIT must be either 0 or 1.  This is the result of the
     following computation:
          (let* ((mask (bitwise-arithmetic-shift-left 1 bitno)))
            (bitwise-if mask
                      (bitwise-arithmetic-shift-left replacement-bit bitno)
                      i))

 -- Procedure: bitwise-bit-field n start end
     Return the integer formed from the (unsigned) bit-field starting at
     START and ending just before END.  Same as:
          (let ((mask
                 (bitwise-not
                  (bitwise-arithmetic-shift-left -1 END))))
            (bitwise-arithmetic-shift-right
              (bitwise-and N mask)
              START))

 -- Procedure: bitwise-copy-bit-field to start end from
     Returns the result of replacing in TO the bits at positions from
     START (inclusive) to END (exclusive) by the bits in FROM from
     position 0 (inclusive) to position END - START (exclusive).  Both
     START and START must be non-negative, and START must be less than
     or equal to START.

     This is the result of the following computation:
          (let* ((mask1
                   (bitwise-arithmetic-shift-left -1 start))
                 (mask2
                   (bitwise-not
                     (bitwise-arithmetic-shift-left -1 end)))
                 (mask (bitwise-and mask1 mask2)))
            (bitwise-if mask
                        (bitwise-arithmetic-shift-left from
                                                       start)
                        to))

 -- Procedure: bitwise-arithmetic-shift i j
     Shifts I by J.  It is a â€œleftâ€ shift if â€˜J>0â€™, and a â€œrightâ€ shift
     if â€˜J<0â€™.  The result is equal to â€˜(floor (* I (expt 2 J)))â€™.

     Examples:
          (bitwise-arithmetic-shift -6 -1) â‡’-3
          (bitwise-arithmetic-shift -5 -1) â‡’ -3
          (bitwise-arithmetic-shift -4 -1) â‡’ -2
          (bitwise-arithmetic-shift -3 -1) â‡’ -2
          (bitwise-arithmetic-shift -2 -1) â‡’ -1
          (bitwise-arithmetic-shift -1 -1) â‡’ -1

 -- Procedure: bitwise-arithmetic-shift-left i amount
 -- Procedure: bitwise-arithmetic-shift-right i amount
     The AMOUNT must be non-negative The â€˜bitwise-arithmetic-shift-leftâ€™
     procedure returns the same result as â€˜bitwise-arithmetic-shiftâ€™,
     and â€˜(bitwise-arithmetic-shift-right I AMOUNT)â€™ returns the same
     result as â€˜(bitwise-arithmetic-shift I (- AMOUNT))â€™.

     If I is a primitive integer type, then AMOUNT must be less than the
     number of bits in the promoted type of I (32 or 64).  If the type
     is unsigned, an unsigned (logic) shift is done for
     â€˜bitwise-arithmetic-shift-rightâ€™, rather than a signed (arithmetic)
     shift.

 -- Procedure: bitwise-rotate-bit-field n start end count
     Returns the result of cyclically permuting in N the bits at
     positions from START (inclusive) to END (exclusive) by COUNT bits
     towards the more significant bits, START and END must be
     non-negative, and START must be less than or equal to END.  This is
     the result of the following computation:
          (let* ((n     ei1)
                 (width (- end start)))
            (if (positive? width)
                (let* ((count (mod count width))
                       (field0
                         (bitwise-bit-field n start end))
                       (field1 (bitwise-arithmetic-shift-left
                                 field0 count))
                       (field2 (bitwise-arithmetic-shift-right
                                 field0
                                 (- width count)))
                       (field (bitwise-ior field1 field2)))
                  (bitwise-copy-bit-field n start end field))
                n))

 -- Procedure: bitwise-reverse-bit-field i start end
     Returns the result obtained from I by reversing the order of the
     bits at positions from START (inclusive) to END (exclusive), where
     START and END must be non-negative, and START must be less than or
     equal to END.
          (bitwise-reverse-bit-field #b1010010 1 4) â‡’  88 ; #b1011000

 -- Procedure: logop op x y
     Perform one of the 16 bitwise operations of X and Y, depending on
     OP.

 -- Procedure: logtest i j
     Returns true if the arguments have any bits in common.  Same as
     â€˜(not (zero? (bitwise-and I J)))â€™, but is more efficient.

11.6.1 SRFI-60 Logical Number Operations
----------------------------------------

Kawa supports SRFI-60 â€œIntegers as Bitsâ€ as well, although we generally
recommend using the R6RS-compatible functions instead when possible.
Unless noted as being a builtin function, to use these you must first
â€˜(require 'srfi-60)â€™ or â€˜(import (srfi :60))â€™ (or â€˜(import (srfi :60
integer-bits))â€™).

 -- Procedure: logand i ...
     Equivalent to â€˜(bitwise-and I ...)â€™.  Builtin.

 -- Procedure: logior i ...
     Equivalent to â€˜(bitwise-ior I ...)â€™.  Builtin.

 -- Procedure: logxor i ...
     Equivalent to â€˜(bitwise-xor I ...)â€™.  Builtin.

 -- Procedure: lognot i
     Equivalent to â€˜(bitwise-not I)â€™.  Builtin.

 -- Procedure: bitwise-merge mask i j
     Equivalent to â€˜(bitwise-if MASK I J)â€™.

 -- Procedure: any-bits-set? i j
     Equivalent to â€˜(logtest I J)â€™.

 -- Procedure: logcount i
 -- Procedure: bit-count i
     Count the number of 1-bits in I, if it is non-negative.  If I is
     negative, count number of 0-bits.  Same as â€˜(bitwise-bit-count I)â€™
     if I is non-negative.  Builtin as â€˜logcountâ€™.

 -- Procedure: integer-length i
     Equivalent to â€˜(bitwise-length I)â€™.  Builtin.

 -- Procedure: log2-binary-factors i
 -- Procedure: first-set-bit i
     Equivalent to â€˜(bitwise-first-bit-set I)â€™.

 -- Procedure: logbit? pos i
 -- Procedure: bit-set? pos i
     Equivalent to â€˜(bitwise-bit-set? I POS)â€™.

 -- Procedure: copy-bit bitno i bool
     Equivalent to â€˜(bitwise-copy-bit I BITNO (if BOOL 1 0))â€™.

 -- Procedure: bit-field n start end
     Equivalent to â€˜(bitwise-bit-field N START END)â€™.

 -- Procedure: copy-bit-field to from start end
     Equivalent to â€˜(bitwise-copy-bit-field TO START END FROM)â€™.

 -- Procedure: arithmetic-shift i j
     Equivalent to â€˜(bitwise-arithmetic-shift I J)â€™.  Builtin.

 -- Procedure: ash i j
     Alias for â€˜arithmetic-shiftâ€™.  Builtin.

 -- Procedure: rotate-bit-field n count start end
     Equivalent to â€˜(bitwise-rotate-bit-field N START END COUNT)â€™.

 -- Procedure: reverse-bit-field i start end
     Equivalent to â€˜(bitwise-reverse-bit-field I START END)â€™.

 -- Procedure: integer->list K [LENGTH]
 -- Procedure: list->integer LIST
     The â€˜integer->listâ€™ procedure returns a list of LENGTH booleans
     corresponding to the bits of the non-negative integer K, with â€˜#tâ€™
     for â€˜1â€™ and â€˜#fâ€™ for â€˜0â€™.  LENGTH defaults to â€˜(bitwise-length K)â€™.
     The list will be in order from MSB to LSB, with the value of â€˜(odd?
     K)â€™ in the last car.

     The â€˜list->integerâ€™ procedure returns the integer corresponding to
     the booleans in the list LIST.  The â€˜integer->listâ€™ and
     â€˜list->integerâ€™ procedures are inverses so far as â€˜equal?â€™ is
     concerned.

 -- Procedure: booleans->integer bool1 ...
     Returns the integer coded by the BOOL1 ...  arguments.  Equivalent
     to â€˜(list->integer (list BOOL1 ...))â€™.

11.6.2 Deprecated Logical Number Operations
-------------------------------------------

This older function is still available, but we recommend using the
R6RS-compatible function.

 -- Procedure: bit-extract n start end
     Equivalent to â€˜(bitwise-bit-field N START END)â€™.


File: kawa.info,  Node: Performance of numeric operations,  Prev: Logical Number Operations,  Up: Numbers

11.7 Performance of numeric operations
======================================

Kawa can generally do a pretty good job of generating efficient code for
numeric operations, at least when it knows or can figure out the types
of the operands.

   The basic operations â€˜+â€™, â€˜-â€™, and â€˜*â€™ are compiled to
single-instruction bytecode if both operands are â€˜intâ€™ or â€˜longâ€™.
Likewise, if both operands are floating-point (or one is floating-point
and the other is rational), then single-instruction â€˜doubleâ€™ or â€˜floatâ€™
instructions are emitted.

   A binary operation involing an infinite-precision â€˜integerâ€™ and a
fixed-size â€˜intâ€™ or â€˜longâ€™ is normally evaluated by expanding the latter
to â€˜integerâ€™ and using â€˜integerâ€™ arithmetic.  An exception is the
â€˜integerâ€™ argument is an integer literal whose value fits in a â€˜intâ€™ or
â€˜longâ€™ - in that case the operation is done using â€˜intâ€™ or â€˜longâ€™
arithmetic.

   In general, integer literals have amorphous type.  When used to infer
the type of a variable, they have â€˜integerâ€™ type:
     (let ((v1 0))
       ... v1 has type integer ... )
   However, a literal whose value fits in the â€˜intâ€™ or â€˜longâ€™ range is
implicitly viewed â€˜intâ€™ or â€˜longâ€™ in certain contexts, primarily method
overload resolution and binary arithmethic (as mentioned above).

   The comparison functions â€˜<â€™, â€˜<=â€™, â€˜=â€™, â€˜>â€™, and â€˜=>â€™ are also
optimized to single instriction operations if the operands have
appropriate type.  However, the functions â€˜zero?â€™, â€˜positive?â€™, and
â€˜negative?â€™ have not yet been optimized.  Instead of â€˜(positive? x)â€™
write â€˜(> x 0)â€™.

   There are a number of integer division and modulo operations.  If the
operands are â€˜intâ€™ or â€˜longâ€™, it is faster to use â€˜quotientâ€™ and
â€˜remainderâ€™ rather than â€˜divâ€™ and â€˜modâ€™ (or â€˜moduloâ€™).  If you know the
first operand is non-negative and the second is positive, then use
â€˜quotientâ€™ and â€˜remainderâ€™.  (If an operand is an arbitrary-precision
â€˜integerâ€™, then it dosnâ€™t really matter.)

   The logical operations â€˜bitwise-andâ€™, â€˜bitwise-iorâ€™, â€˜bitwise-xorâ€™,
â€˜bitwise-notâ€™, â€˜bitwise-arithmetic-shift-leftâ€™,
â€˜bitwise-arithmetic-shift-rightâ€™ are compiled to single bitcode
instructions if the operands are â€˜intâ€™ or â€˜longâ€™.  Avoid
â€˜bitwise-arithmetic-shiftâ€™ if the sign of the shift is known.  If the
operands are arbitrary-precision â€˜integerâ€™, a library call is needed,
but run-time type dispatch is avoided.


File: kawa.info,  Node: Characters and text,  Next: Data structures,  Prev: Numbers,  Up: Top

12 Characters and text
**********************

* Menu:

* Characters::
* Character sets::
* Strings::
* String literals::
* Unicode::              Unicode character classes and conversions
* Regular expressions::


File: kawa.info,  Node: Characters,  Next: Character sets,  Up: Characters and text

12.1 Characters
===============

Characters are objects that represent human-readable characters such as
letters and digits.  More precisely, a character represents a Unicode
scalar value (http://www.unicode.org/glossary/#unicode_scalar_value).
Each character has an integer value in the range â€˜0â€™ to â€˜#x10FFFFâ€™
(excluding the range â€˜#xD800â€™ to â€˜#xDFFFâ€™ used for Surrogate Code Points
(http://www.unicode.org/glossary/#surrogate_code_point)).

     _Note:_ Unicode distinguishes between glyphs, which are printed for
     humans to read, and characters, which are abstract entities that
     map to glyphs (sometimes in a way thatâ€™s sensitive to surrounding
     characters).  Furthermore, different sequences of scalar values
     sometimes correspond to the same character.  The relationships
     among scalar, characters, and glyphs are subtle and complex.

     Despite this complexity, most things that a literate human would
     call a â€œcharacterâ€ can be represented by a single Unicode scalar
     value (although several sequences of Unicode scalar values may
     represent that same character).  For example, Roman letters,
     Cyrillic letters, Hebrew consonants, and most Chinese characters
     fall into this category.

     Unicode scalar values exclude the range â€˜#xD800â€™ to â€˜#xDFFFâ€™, which
     are part of the range of Unicode "code points".  However, the
     Unicode code points in this range, the so-called "surrogates", are
     an artifact of the UTF-16 encoding, and can only appear in specific
     Unicode encodings, and even then only in pairs that encode scalar
     values.  Consequently, all characters represent code points, but
     the surrogate code points do not have representations as
     characters.

 -- Type: character
     A Unicode code point - normally a Unicode scalar value, but could
     be a surrogate.  This is implemented using a 32-bit â€˜intâ€™.  When an
     object is needed (i.e.  the "boxed" representation), it is
     implemented an instance of â€˜gnu.text.Charâ€™.

 -- Type: character-or-eof
     A â€˜characterâ€™ or the specical â€˜#!eofâ€™ value (used to indicate
     end-of-file when reading from a port).  This is implemented using a
     32-bit â€˜intâ€™, where the value -1 indicates end-of-file.  When an
     object is needed, it is implemented an instance of â€˜gnu.text.Charâ€™
     or the special â€˜#!eofâ€™ object.

 -- Type: char
     A UTF-16 code unit.  Same as Java primitive â€˜charâ€™ type.
     Considered to be a sub-type of â€˜characterâ€™.  When an object is
     needed, it is implemented as an instance of â€˜java.lang.Characterâ€™.
     Note the unfortunate inconsistency (for historical reasons) of
     â€˜charâ€™ boxed as â€˜Characterâ€™ vs â€˜characterâ€™ boxed as â€˜Charâ€™.

   Characters are written using the notation â€˜#\â€™CHARACTER (which stands
for the given CHARACTER; â€˜#\xâ€™HEX-SCALAR-VALUE (the character whose
scalar value is the given hex integer); or â€˜#\â€™CHARACTER-NAME (a
character with a given name):

     CHARACTER ::= â€˜#\â€™ANY-CHARACTER
             | â€˜#\â€™ CHARACTER-NAME
             | â€˜#\xâ€™ HEX-SCALAR-VALUE
             | â€˜#\Xâ€™ HEX-SCALAR-VALUE

   The following CHARACTER-NAME forms are recognized:
â€˜#\alarmâ€™
     â€˜#\x0007â€™ - the alarm (bell) character
â€˜#\backspaceâ€™
     â€˜#\x0008â€™
â€˜#\deleteâ€™
â€˜#\delâ€™
â€˜#\ruboutâ€™
     â€˜#\x007fâ€™ - the delete or rubout character
â€˜#\escapeâ€™
â€˜#\escâ€™
     â€˜#\x001bâ€™
â€˜#\newlineâ€™
â€˜#\linefeedâ€™
     â€˜#\x001aâ€™ - the linefeed character
â€˜#\nullâ€™
â€˜#\nulâ€™
     â€˜#\x0000â€™ - the null character
â€˜#\pageâ€™
     â€˜#\000câ€™ - the formfeed character
â€˜#\returnâ€™
     â€˜#\000dâ€™ - the carriage return character
â€˜#\spaceâ€™
     â€˜#\x0020â€™ - the preferred way to write a space
â€˜#\tabâ€™
     â€˜#\x0009â€™ - the tab character
â€˜#\vtabâ€™
     â€˜#\x000bâ€™ - the vertical tabulation character
â€˜#\ignorable-charâ€™
     A special â€˜characterâ€™ value, but it is not a Unicode code point.
     It is a special value returned when an index refers to the second
     â€˜charâ€™ (code point) of a surrogate pair, and which should be
     ignored.  (When writing a â€˜characterâ€™ to a string or file, it will
     be written as one or two â€˜charâ€™ values.  The exception is
     â€˜#\ignorable-charâ€™, for which zero â€˜charâ€™ values are written.)

 -- Procedure: char? OBJ
     Return â€˜#tâ€™ if OBJ is a character, â€˜#fâ€™ otherwise.  (The OBJ can be
     any character, not just a 16-bit â€˜charâ€™.)

 -- Procedure: char->integer CHAR
 -- Procedure: integer->char SV
     SV should be a Unicode scalar value, i.e., a nonâ€“negative exact
     integer object in â€˜[0, #xD7FF] union [#xE000, #x10FFFF]â€™.  (Kawa
     also allows values in the surrogate range.)

     Given a character, â€˜char->integerâ€™ returns its Unicode scalar value
     as an exact integer object.  For a Unicode scalar value SV,
     â€˜integer->charâ€™ returns its associated character.

          (integer->char 32)                     â‡’ #\space
          (char->integer (integer->char 5000))   â‡’ 5000
          (integer->char #\xD800)                â‡’ throws ClassCastException

     _Performance note:_ A call to â€˜char->integerâ€™ is compiled as
     casting the argument to a â€˜characterâ€™, and then re-interpreting
     that value as an â€˜intâ€™.  A call to â€˜integer->charâ€™ is compiled as
     casting the argument to an â€˜intâ€™, and then re-interpreting that
     value as an â€˜characterâ€™.  If the argument is the right type, no
     code is emitted: the value is just re-interpreted as the result
     type.

 -- Procedure: char=? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char<? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char>? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char<=? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char>=? CHAR1 CHAR2 CHAR3 â€¦
     These procedures impose a total ordering on the set of characters
     according to their Unicode scalar values.

          (char<? #\z #\ÃŸ)      â‡’ #t
          (char<? #\z #\Z)      â‡’ #f

     _Performance note:_ This is compiled as if converting each argument
     using â€˜char->integerâ€™ (which requires no code) and the using the
     corresponing â€˜intâ€™ comparison.

 -- Procedure: digit-value char
     This procedure returns the numeric value (0 to 9) of its argument
     if it is a numeric digit (that is, if â€˜char-numeric?â€™ returns
     â€˜#tâ€™), or â€˜#fâ€™ on any other character.

          (digit-value #\3)        â‡’ 3
          (digit-value #\x0664)    â‡’ 4
          (digit-value #\x0AE6)    â‡’ 0
          (digit-value #\x0EA6)    â‡’ #f


File: kawa.info,  Node: Character sets,  Next: Strings,  Prev: Characters,  Up: Characters and text

12.2 Character sets
===================

Sets of characters are useful for text-processing code, including
parsing, lexing, and pattern-matching.  SRFI 14
(http://srfi.schemers.org/srfi-14/srfi-14.html) specifies a â€˜char-setâ€™
type for such uses.  Some examples:

     (import (srfi :14 char-sets))
     (define vowel (char-set #\a #\e #\i #\o #\u))
     (define vowely (char-set-adjoin vowel #\y))
     (char-set-contains? vowel #\y) â‡’  #f
     (char-set-contains? vowely #\y) â‡’  #t

   See the SRFI 14 specification
(http://srfi.schemers.org/srfi-14/srfi-14.html) for details.

 -- Type: char-set
     The type of character sets.  In Kawa â€˜char-setâ€™ is a type that can
     be used in type specifiers:
          (define vowely ::char-set (char-set-adjoin vowel #\y))

   Kawa uses inversion lists
(http://www.ibm.com/developerworks/linux/library/l-cpinv.html) for an
efficient implementation, using Java â€˜intâ€™ arrays to represents
character ranges (inversions).  The â€˜char-set-contains?â€™ function uses
binary search, so it takes time proportional to the logarithm of the
number of inversions.  Other operations may take time proportional to
the number of inversions.


File: kawa.info,  Node: Strings,  Next: String literals,  Prev: Character sets,  Up: Characters and text

12.3 Strings
============

Strings are sequences of characters.  The _length_ of a string is the
number of characters that it contains, as an exact non-negative integer.
This number is usually fixed when the string is created, however, you
can extend a mutable string with the (Kawa-specific) â€˜string-append!â€™
function.  The _valid indices_ of a string are the exact non-negative
integers less than the length of the string.  The first character of a
string has index 0, the second has index 1, and so on.

   Strings are _implemented_ as a sequence of 16-bit â€˜charâ€™ values, even
though theyâ€™re semantically a sequence of 32-bit Unicode code points.  A
character whose value is greater than â€˜#xffffâ€™ is represented using two
surrogate characters.  The implementation allows for natural
interoperability with Java APIs.  However it does make certain
operations (indexing or counting based on character counts) difficult to
implement efficiently.  Luckily one rarely needs to index or count based
on character counts; alternatives are discussed below.

   Some of the procedures that operate on strings ignore the difference
between upper and lower case.  The names of the versions that ignore
case end with â€œâ€˜-ciâ€™â€ (for â€œcase insensitiveâ€).

 -- Type: string
     The type of string objects.  The underlying type is the interface
     â€˜java.lang.CharSequenceâ€™.  Immultable strings are
     â€˜java.lang.Stringâ€™, while mutable strings are â€˜gnu.lists.FStringâ€™.

12.3.1 Basic string procedures
------------------------------

 -- Procedure: string? OBJ
     Return â€˜#tâ€™ if OBJ is a string, â€˜#fâ€™ otherwise.

 -- Constructor: string CHAR â€¦
     Return a newly allocated string composed of the arguments.  This is
     analogous to LIST.

 -- Procedure: make-string K
 -- Procedure: make-string K CHAR
     Return a newly allocated string of length K.  If CHAR is given,
     then all elements of the string are initialized to CHAR, otherwise
     the contents of the STRING are unspecified.

 -- Procedure: string-length STRING
     Return the number of characters in the given STRING as an exact
     integer object.

     _Performance note:_ Calling â€˜string-lengthâ€™ may take time
     propertial to the length of the STRING, because of the need to scan
     for surrogate pairs.

 -- Procedure: string-ref STRING K
     K must be a valid index of STRING.  The â€˜string-refâ€™ procedure
     returns character K of STRING using zeroâ€“origin indexing.

     _Performance note:_ Calling â€˜string-refâ€™ may take time propertial
     to K because of the need to check for surrogate pairs.  An
     alternative is to use â€˜string-cursor-refâ€™.  If iterating through a
     string, use â€˜string-for-eachâ€™.

 -- Procedure: string-set! string k char
     This procedure stores CHAR in element K of STRING.

          (define s1 (make-string 3 #\*))
          (define s2 "***")
          (string-set! s1 0 #\?) â‡’ _void_
          s1 â‡’ "?**"
          (string-set! s2 0 #\?) â‡’ _error_
          (string-set! (symbol->string 'immutable) 0 #\?) â‡’ _error_

     _Performance note:_ Calling â€˜string-set!â€™ may take time propertial
     to the length of the string: First it must scan for the right
     position, like â€˜string-refâ€™ does.  Then if the new character
     requires using a surrogate pair (and the old one doesnâ€™t) then we
     have to make rom in the string, possible re-allocating a new â€˜charâ€™
     array.  Alternatively, if the old character requires using a
     surrogate pair (and the new one doesnâ€™t) then following characters
     need to be moved.

     The function â€˜string-set!â€™ is deprecated: It is inefficient, and it
     very seldom does the correct thing.  Instead, you can construct a
     string with â€˜string-append!â€™.

 -- Procedure: substring STRING START END
     STRING must be a string, and START and END must be exact integer
     objects satisfying:

          0 <= START <= END <= (string-length STRING)

     The â€˜substringâ€™ procedure returns a newly allocated string formed
     from the characters of STRING beginning with index START
     (inclusive) and ending with index END (exclusive).

 -- Procedure: string-append STRING â€¦
     Return a newly allocated string whose characters form the
     concatenation of the given strings.

 -- Procedure: string-append! STRING VALUE â€¦
     The STRING must be a mutable string, such as one returned by
     â€˜make-stringâ€™ or â€˜string-copyâ€™.  The â€˜string-append!â€™ procedure
     extends STRING by appending each VALUE (in order) to the end of
     STRING.  Each â€˜valueâ€™ should be a character or a string.

     _Performance note:_ The compiler converts a call with multiple
     VALUEs to a multiple â€˜string-append!â€™ calls.  If a VALUE is known
     to be a â€˜characterâ€™, then no boxing (object-allocation) is needed.

     The following example show to to efficiently process a string using
     â€˜string-for-eachâ€™ and incrementally â€œbuildingâ€ a result string
     using â€˜string-append!â€™.

          (define (translate-space-to-newline str::string)::string
            (let ((result (make-string 0)))
              (string-for-each
               (lambda (ch)
                 (string-append! result
                                 (if (char=? ch #\Space) #\Newline ch)))
               str)
              result))

 -- Procedure: string->list STRING [START [END]]
 -- Procedure: list->string LIST
     It is an error if any element of LIST is not a character.

     The â€˜string->listâ€™ procedure returns a newly allocated list of the
     characters of STRING between START and END.  The â€˜list->stringâ€™
     procedure returns a newly allocated string formed from the
     characters in LIST.  In both procedures, order is preserved.  The
     â€˜string->listâ€™ and â€˜list->stringâ€™ procedures are inverses so far as
     â€˜equal?â€™ is concerned.

 -- Procedure: string-for-each PROC STRING1 STRING2 â€¦
 -- Procedure: string-for-each PROC STRING1 [start [end]]
     The STRINGs must all have the same length.  PROC should accept as
     many arguments as there are STRINGs.

     The START-END variant is provided for compatibility with the
     SRFI-13 version.  (In that case START and END count code Unicode
     scalar values (â€˜characterâ€™ values), not Java 16-bit â€˜charâ€™ values.)

     The â€˜string-for-eachâ€™ procedure applies PROC elementâ€“wise to the
     characters of the STRINGs for its side effects, in order from the
     first characters to the last.  PROC is always called in the same
     dynamic environment as â€˜string-for-eachâ€™ itself.

     Analogous to â€˜for-eachâ€™.

          (let ((v '()))
            (string-for-each
              (lambda (c) (set! v (cons (char->integer c) v)))
              "abcde")
             v)
            â‡’ (101 100 99 98 97)

     _Performance note:_ The compiler generates efficient code for
     â€˜string-for-eachâ€™.  If PROC is a lambda expression, it is inlined,

 -- Procedure: string-map PROC STRING1 STRING2 â€¦
     The â€˜string-mapâ€™ procedure applies PROC element-wise to the
     elements of the strings and returns a string of the results, in
     order.  It is an error if PROC does not accept as many arguments as
     there are strings, or return other than a single character.  If
     more than one string is given and not all strings have the same
     length, â€˜string-mapâ€™ terminates when the shortest string runs out.
     The dynamic order in which PROC is applied to the elements of the
     strings is unspecified.

          (string-map char-foldcase "AbdEgH")  â‡’ "abdegh"
          (string-map
            (lambda (c) (integer->char (+ 1 (char->integer c))))
            "HAL")
                  â‡’ "IBM"
          (string-map
            (lambda (c k)
              ((if (eqv? k #\u) char-upcase char-downcase) c))
            "studlycaps xxx"
            "ululululul")
                  â‡’ "StUdLyCaPs"

     _Performance note:_ The â€˜string-mapâ€™ procedure has not been
     optimized (mainly because it is not very useful): The characters
     are boxed, and the PROC is not inlined even if a lambda expression.

 -- Procedure: string-copy STRING [START [END]]
     Returns a newly allocated copy of the the part of the given STRING
     between START and END.

 -- Procedure: string-replace! DST DST-START DST-END SRC [SRC-START
          [SRC-END]]
     Replaces the characters of string DST (between DST-START and
     DST-END) with the characters of SRC (between SRC-START and
     SRC-END).  The number of characters from SRC may be different than
     the number replaced in DST, so the string may grow or contract.
     The special case where DST-START is equal to DST-END corresponds to
     insertion; the case where SRC-START is equal to SRC-END corresponds
     to deletion.  The order in which characters are copied is
     unspecified, except that if the source and destination overlap,
     copying takes places as if the source is first copied into a
     temporary string and then into the destination.  (This is achieved
     without allocating storage by making sure to copy in the correct
     direction in such circumstances.)

 -- Procedure: string-copy! TO AT FROM [START [END]]
     Copies the characters of the string FROM that are between START end
     END into the string TO, starting at index AT.  The order in which
     characters are copied is unspecified, except that if the source and
     destination overlap, copying takes places as if the source is first
     copied into a temporary string and then into the destination.
     (This is achieved without allocating storage by making sure to copy
     in the correct direction in such circumstances.)

     This is equivalent to (and implemented as):
          (string-replace! to at (+ at (- end start)) from start end))

          (define a "12345")
          (define b (string-copy "abcde"))
          (string-copy! b 1 a 0 2)
          b  â‡’  "a12de"

 -- Procedure: string-fill! STRING FILL [START [END]]
     The â€˜string-fill!â€™ procedure stores FILL in the elements of STRING
     between START and END.  It is an error if FILL is not a character
     or is forbidden in strings.

12.3.2 String Comparisons
-------------------------

 -- Procedure: string=? STRING1 STRING2 STRING3 â€¦
     Return â€˜#tâ€™ if the strings are the same length and contain the same
     characters in the same positions.  Otherwise, the â€˜string=?â€™
     procedure returns â€˜#fâ€™.

          (string=? "StraÃŸe" "Strasse")    â‡’ #f

 -- Procedure: string<? STRING1 STRING2 STRING3 â€¦
 -- Procedure: string>? STRING1 STRING2 STRING3 â€¦
 -- Procedure: string<=? STRING1 STRING2 STRING3 â€¦
 -- Procedure: string>=? STRING1 STRING2 STRING3 â€¦
     These procedures return â€˜#tâ€™ if their arguments are (respectively):
     monotonically increasing, monotonically decreasing, monotonically
     non-decreasing, or monotonically nonincreasing.  These predicates
     are required to be transitive.

     These procedures are the lexicographic extensions to strings of the
     corresponding orderings on characters.  For example, â€˜string<?â€™ is
     the lexicographic ordering on strings induced by the ordering
     â€˜char<?â€™ on characters.  If two strings differ in length but are
     the same up to the length of the shorter string, the shorter string
     is considered to be lexicographically less than the longer string.

          (string<? "z" "ÃŸ")      â‡’ #t
          (string<? "z" "zz")     â‡’ #t
          (string<? "z" "Z")      â‡’ #f

 -- Procedure: string-ci=? STRING1 STRING2 STRING3 â€¦
 -- Procedure: string-ci<? STRING1 STRING2 STRING3 â€¦
 -- Procedure: string-ci>? STRING1 STRING2 STRING3 â€¦
 -- Procedure: string-ci<=? STRING1 STRING2 STRING3 â€¦
 -- Procedure: string-ci>=? STRING1 STRING2 STRING3 â€¦
     These procedures are similar to â€˜string=?â€™, etc., but behave as if
     they applied â€˜string-foldcaseâ€™ to their arguments before invokng
     the corresponding procedures without â€˜-ciâ€™.

          (string-ci<? "z" "Z")                   â‡’ #f
          (string-ci=? "z" "Z")                   â‡’ #t
          (string-ci=? "StraÃŸe" "Strasse")        â‡’ #t
          (string-ci=? "StraÃŸe" "STRASSE")        â‡’ #t
          (string-ci=? "Î§Î‘ÎŸÎ£" "Ï‡Î±Î¿Ïƒ")             â‡’ #t

12.3.3 String Conversions
-------------------------

 -- Procedure: string-upcase STRING
 -- Procedure: string-downcase STRING
 -- Procedure: string-titlecase STRING
 -- Procedure: string-foldcase STRING
     These procedures take a string argument and return a string result.
     They are defined in terms of Unicodeâ€™s localeâ€“independent case
     mappings from Unicode scalarâ€“value sequences to scalarâ€“value
     sequences.  In particular, the length of the result string can be
     different from the length of the input string.  When the specified
     result is equal in the sense of â€˜string=?â€™ to the argument, these
     procedures may return the argument instead of a newly allocated
     string.

     The â€˜string-upcaseâ€™ procedure converts a string to upper case;
     â€˜string-downcaseâ€™ converts a string to lower case.  The
     â€˜string-foldcaseâ€™ procedure converts the string to its caseâ€“folded
     counterpart, using the full caseâ€“folding mapping, but without the
     special mappings for Turkic languages.  The â€˜string-titlecaseâ€™
     procedure converts the first cased character of each word, and
     downcases all other cased characters.

          (string-upcase "Hi")              â‡’ "HI"
          (string-downcase "Hi")            â‡’ "hi"
          (string-foldcase "Hi")            â‡’ "hi"

          (string-upcase "StraÃŸe")          â‡’ "STRASSE"
          (string-downcase "StraÃŸe")        â‡’ "straÃŸe"
          (string-foldcase "StraÃŸe")        â‡’ "strasse"
          (string-downcase "STRASSE")       â‡’ "strasse"

          (string-downcase "Î£")             â‡’ "Ïƒ"
          ; Chi Alpha Omicron Sigma:
          (string-upcase "Î§Î‘ÎŸÎ£")            â‡’ "Î§Î‘ÎŸÎ£"
          (string-downcase "Î§Î‘ÎŸÎ£")          â‡’ "Ï‡Î±Î¿Ï‚"
          (string-downcase "Î§Î‘ÎŸÎ£Î£")         â‡’ "Ï‡Î±Î¿ÏƒÏ‚"
          (string-downcase "Î§Î‘ÎŸÎ£ Î£")        â‡’ "Ï‡Î±Î¿Ï‚ Ïƒ"
          (string-foldcase "Î§Î‘ÎŸÎ£Î£")         â‡’ "Ï‡Î±Î¿ÏƒÏƒ"
          (string-upcase "Ï‡Î±Î¿Ï‚")            â‡’ "Î§Î‘ÎŸÎ£"
          (string-upcase "Ï‡Î±Î¿Ïƒ")            â‡’ "Î§Î‘ÎŸÎ£"

          (string-titlecase "kNock KNoCK")  â‡’ "Knock Knock"
          (string-titlecase "who's there?") â‡’ "Who's There?"
          (string-titlecase "r6rs")         â‡’ "R6rs"
          (string-titlecase "R6RS")         â‡’ "R6rs"

          _Note:_ The case mappings needed for implementing these
          procedures can be extracted from â€˜UnicodeData.txtâ€™,
          â€˜SpecialCasing.txtâ€™, â€˜WordBreakProperty.txtâ€™ (the â€œMidLetterâ€
          property partly defines caseâ€“ignorable characters), and
          â€˜CaseFolding.txtâ€™ from the Unicode Consortium.

          Since these procedures are localeâ€“independent, they may not be
          appropriate for some locales.

          _Note:_ Word breaking, as needed for the correct casing of the
          upper case greek sigma and for â€˜string-titlecaseâ€™, is
          specified in Unicode Standard Annex #29.

          _Kawa Note:_ The implementation of â€˜string-titlecaseâ€™ does not
          correctly handle the case where an initial character needs to
          be converted to multiple characters, such as â€œLATIN SMALL
          LIGATURE FLâ€ which should be converted to the two letters
          â€˜"Fl"â€™.

 -- Procedure: string-normalize-nfd STRING
 -- Procedure: string-normalize-nfkd STRING
 -- Procedure: string-normalize-nfc STRING
 -- Procedure: string-normalize-nfkc STRING
     These procedures take a string argument and return a string result,
     which is the input string normalized to Unicode normalization form
     D, KD, C, or KC, respectively.  When the specified result is equal
     in the sense of â€˜string=?â€™ to the argument, these procedures may
     return the argument instead of a newly allocated string.

          (string-normalize-nfd "\xE9;")          â‡’ "\x65;\x301;"
          (string-normalize-nfc "\xE9;")          â‡’ "\xE9;"
          (string-normalize-nfd "\x65;\x301;")    â‡’ "\x65;\x301;"
          (string-normalize-nfc "\x65;\x301;")    â‡’ "\xE9;"

12.3.4 Strings as sequences
---------------------------

12.3.4.1 Indexing a string
..........................

Using function-call syntax with strings is convenient and efficient.
However, it has some â€œgotchasâ€.

   We will use the following example string:
     (! str1 "Smile \x1f603;!")
   or if youâ€™re brave:
     (! str1 "Smile ğŸ˜ƒ!")

   This is â€˜"Smile "â€™ followed by an emoticon (â€œsmiling face with open
mouthâ€) followed by â€˜"!"â€™.  The emoticon has scalar value â€˜\x1f603â€™ - it
is not in the 16-bit Basic Multi-language Plane, and so it must be
encoded by a surrogate pair (â€˜#\xd83dâ€™ followed by â€˜#\xde03â€™).

   The number of scalar values (â€˜characterâ€™s) is 8, while the number of
16-bits code units (â€˜charâ€™s) is 9.  The â€˜java.lang.CharSequence#lengthâ€™
method counts â€˜charâ€™s; the â€˜lengthâ€™ function calls that method; the
â€˜string-lengthâ€™ procedure counts â€˜characterâ€™s.  Thus:

     (length str1)          â‡’ 9
     (str1:length)          â‡’ 9
     (string-length str1)   â‡’ 8

   Counting â€˜charâ€™s is a constant-time operation (since it is stored in
the data structure), while counting â€˜characterâ€™s takes time propertional
to the length of the string, since it has subtract one for each
surrogate pair.

   Similarly we can can index the string in 3 ways:

     (str1 1)              â‡’ #\m :: character
     (str1:charAt 1)       â‡’ #\m :: char
     (string-ref str1 1)   â‡’ #\m :: character

   Note using the function-call syntax returns a â€˜characterâ€™.

   Things become interesting when we reach the emoticon:

     (str1 6)              â‡’ #\ğŸ˜ƒ :: character
     (str1:charAt 6)       â‡’ #\d83d :: char
     (string-ref str1 6)   â‡’ #\ğŸ˜ƒ :: character

   Both â€˜string-refâ€™ and the function-call syntax return the real
character, while the â€˜charAtâ€™ methods returns a partial character.
However, â€˜string-refâ€™ needs to linearly count from the start of the
string, while the function-call syntax can do a constant-time lookup.
It does this by calling â€˜(str1:charAt 6)â€™ first.  If that returns a
leading-surrogate character, it checks that the next character (i.e.
â€˜(str1:charAt 7)â€™) is a trailing-surrogate character, and if so combines
the two.  (If there is no next character or it is not a
trailing-surrogate, then indexing just returns the leading-surrogate
partial character.)

   In other words â€˜(string-ref s i)â€™ returns the â€˜iâ€™â€™th â€˜characterâ€™,
while â€˜(s i)â€™ return the â€˜characterâ€™ at the â€˜iâ€™â€™th index.

   If the character at the â€˜iâ€™â€™th index is a surrogate pair, then â€˜(s (+
i 1))â€™ returns a special pseudo-character named â€˜#\ignorable-charâ€™.
This pseudo-character should generally be ignored.  (It is automatically
ignored by Kawa functions including â€˜write-charâ€™, â€˜string-append!â€™, and
the â€˜stringâ€™ constructor.)

     (str1 7)              â‡’ #\ignorable-char :: character
     (str1 8)              â‡’ #\! :: character
     (str1:charAt 7)       â‡’ #\de03 :: char
     (str1:charAt 8)       â‡’ #\! :: char
     (string-ref str1 7)   â‡’ #\! :: character
     (string-ref str1 8)   â‡’ throws StringIndexOutOfBoundsException

   Following are two possible implementations of a single-string version
of â€˜string-for-eachâ€™.  The â€˜string-for-each-1â€™ version is simple,
obvious, and traditional - but the execution time is quadratic in the
string length.  The â€˜string-for-each-2â€™ version requires filtering out
any â€˜#\ignorable-charâ€™, but the execution time is only linear.

     (define (string-for-each-1 proc s::string)
       (! slen (string-length s))
       (do ((i ::int 0 (+ i 1))) ((= i slen))
         (proc (string-ref s i))))

     (define (string-for-each-2 proc s::string)
       (! slen (length s))
       (do ((i ::int 0 (+ i 1))) ((= i slen))
         (let ((ch (s i)))
           (if (not (char=? ch #\ignorable-char))
               (proc ch)))))

12.3.4.2 Indexing with a sequence
.................................

You can index a string with a list of integer indexes, most commonly a
range:
     (STR [I ...])
   is basically the same as:
     (string (STR:charAt I) ...)
   This is usually the same as the following:
     (string (STR I) ...)
   (The exception is if you select only part of a surrogate pair.)

   Generally when working with strings it is best to work with
substrings rather than individual characters:
     (STR [START <: END])
   This is equivalent to invoking the â€˜CharSequence:subSequenceâ€™ method:
     (STR:subSequence START END)
   This is much more efficient than the â€˜substringâ€™ procedure, since the
latter has to convert â€˜characterâ€™ indexes to â€˜charâ€™ offsets.

12.3.5 String Cursor API
------------------------

Indexing into a string (using for example â€˜string-refâ€™) is inefficient
because of the possible presence of surrogate pairs.  Hence given an
index I access normally requires linearly scanning the string until we
have seen I characters.

   The string-cursor API is defined in terms of abstract â€œcursor
valuesâ€, which point to a position in the string.  This avoids the
linear scan.

   The API is non-standard, but is based on that in Chibi Scheme.

 -- Type: string-cursor
     An abstract posistion (index) in a string.  Implemented as a
     primitive â€˜intâ€™ which counts the number of preceding code units
     (16-bit â€˜charâ€™ values).

 -- Procedure: string-cursor-start str
     Returns a cursor for the start of the string.  The result is always
     0, cast to a â€˜string-cursorâ€™.

 -- Procedure: string-cursor-end str
     Returns a cursor for the end of the string - one past the last
     valid character.  Implemented as â€˜(as string-cursor (invoke STR
     'length))â€™.

 -- Procedure: string-cursor-ref str cursor
     Return the â€˜characterâ€™ at the CURSOR.

 -- Procedure: string-cursor-next string cursor [count]
     Return the cursor position COUNT (default 1) character positions
     forwards beyond CURSOR.  For each COUNT this may add either 1 or 2
     (if pointing at a surrogate pair) to the CURSOR.

 -- Procedure: string-cursor-prev string cursor [count]
     Return the cursor position COUNT (default 1) character positions
     backwards before CURSOR.

 -- Procedure: substring-cursor string [start [end]]
     Create a substring of the section of STRING between the cursors
     START and END.

 -- Procedure: string-cursor<? cursor1 cursor2
 -- Procedure: string-cursor<=? cursor1 cursor2
 -- Procedure: string-cursor=? cursor1 cursor2
 -- Procedure: string-cursor>=? cursor1 cursor2
 -- Procedure: string-cursor>? cursor1 cursor2
     Is the position of CURSOR1 respectively before, before or same,
     same, after, or after or same, as CURSOR2.

     _Performance note:_ Implemented as the corresponding â€˜intâ€™
     comparison.

 -- Procedure: string-cursor-for-each proc string [start [end]]
     Apply the procedure PROC to each character position in STRING
     between the cursors START and END.


File: kawa.info,  Node: String literals,  Next: Unicode,  Prev: Strings,  Up: Characters and text

12.4 String literals
====================

Kaw support two syntaxes of string literals: The traditional, portable,
qdouble-quoted-delimited literals like â€˜"this"â€™; and extended SRFI-109
quasi-literals like â€˜&{this}â€™.

12.4.1 Simple string literals
-----------------------------

     STRING ::= â€˜"â€™STRING-ELEMENT^*â€˜"â€™
     STRING-ELEMENT ::= any character other than â€˜"â€™ or â€˜\â€™
         | MNEMONIC-ESCAPE | â€˜\"â€™ | â€˜\\â€™
         | â€˜\â€™INTRALINE-WHITESPACE^*LINE-ENDING INTRALINE-WHITESPACE^*
         | INLINE-HEX-ESCAPE
     MNEMONIC-ESCAPE ::= â€˜\aâ€™ | â€˜\bâ€™ | â€˜\tâ€™ | â€˜\nâ€™ | â€˜\râ€™ | ... (see below)

   A string is written as a sequence of characters enclosed within
quotation marks (â€˜"â€™).  Within a string literal, various escape sequence
represent characters other than themselves.  Escape sequences always
start with a backslash (â€˜\â€™):
â€˜\aâ€™
     Alarm (bell), â€˜#\x0007â€™.
â€˜\bâ€™
     Backspace, â€˜#\x0008â€™.
â€˜\eâ€™
     Escape, â€˜#\x001Bâ€™.
â€˜\fâ€™
     Form feed, â€˜#\x000Câ€™.
â€˜\nâ€™
     Linefeed (newline), â€˜#\x000Aâ€™.
â€˜\râ€™
     Return, â€˜#\x000Dâ€™.
â€˜\tâ€™
     Character tabulation, â€˜#\x0009â€™.
â€˜\vâ€™
     Vertical tab, â€˜#\x000Bâ€™.
â€˜\C-â€™X
â€˜\^â€™X
     Returns the scalar value of X masked (anded) with â€˜#x9Fâ€™.  An
     alternative way to write the Ascii control characters: For example
     â€˜"\C-m"â€™ or â€˜"\^m"â€™ is the same as â€˜"#\x000D"â€™ (which the same as
     â€˜"\r"â€™).  As a special case â€˜\^?â€™ is rubout (delete) (â€˜\x7f;â€™).
â€˜\xâ€™ HEX-SCALAR-VALUEâ€˜;â€™
â€˜\Xâ€™ HEX-SCALAR-VALUEâ€˜;â€™
     A hex encoding that gives the scalar value of a character.
â€˜\\â€™ OCT-DIGIT^+
     At most three octal digits that give the scalar value of a
     character.  (Historical, for C compatibility.)
â€˜\uâ€™ HEX-DIGIT^+
     Exactly four hex digits that give the scalar value of a character.
     (Historical, for Java compatibility.)
â€˜\M-â€™X
     (Historical, for Emacs Lisp.)  Set the meta-bit (high-bit of single
     byte) of the following character X.
â€˜\|â€™
     Vertical line, â€˜#\x007câ€™.  (Not useful for string literals, but
     useful for symbols.)
â€˜\"â€™
     Double quote, â€˜#\x0022â€™.
â€˜\\â€™
     Backslah, â€˜#\005Câ€™.
â€˜\â€™INTRALINE-WHITESPACE^*LINE-ENDING INTRALINE-WHITESPACE^*
     Nothing (ignored).  Allows you to split up a long string over
     multiple lines; ignoring initial whitespace on the continuation
     lines allows you to indent them.

   Except for a line ending, any character outside of an escape sequence
stands for itself in the string literal.  A line ending which is
preceded by â€˜\â€™INTRALINE-WHITESPACE^* expands to nothing (along with any
trailing INTRALINE-WHITESPACE), and can be used to indent strings for
improved legibility.  Any other line ending has the same effect as
inserting a â€˜\nâ€™ character into the string.

   Examples:
     "The word \"recursion\" has many meanings."
     "Another example:\ntwo lines of text"
     "Hereâ€™s text \
     containing just one line"
     "\x03B1; is named GREEK SMALL LETTER ALPHA."

12.4.2 String templates
-----------------------

The following syntax is a "string template" (also called a string
quasi-literal or â€œhere document
(http://en.wikipedia.org/wiki/Here_document)â€):
     &{Hello &[name]!}
   Assuming the variable â€˜nameâ€™ evaluates to â€˜"John"â€™ then the example
evaluates to â€˜"Hello John!"â€™.

   The Kawa reader converts the above example to:
     ($string$ "Hello " $<<$ name $>>$ "!")
   See the SRFI-109 (http://srfi.schemers.org/srfi-109/srfi-109.html)
specification for details.

     EXTENDED-STRING-LITERAL ::= â€˜&{â€™ [INITIAL-IGNORED] STRING-LITERAL-PART^* â€˜}â€™
     STRING-LITERAL-PART ::=  any character except â€˜&â€™, â€˜{â€™ or â€˜}â€™
         | â€˜{â€™ STRING-LITERAL-PART^* â€˜}â€™
         | CHAR-REF
         | ENTITY-REF
         | SPECIAL-ESCAPE
         | ENCLOSED-PART

   You can use the plain â€˜"STRING"â€™ syntax for longer multiline strings,
but â€˜&{STRING}â€™ has various advantages.  The syntax is less error-prone
because the start-delimiter is different from the end-delimiter.  Also
note that nested braces are allowed: a right brace â€˜}â€™ is only an
end-delimiter if it is unbalanced, so you would seldom need to escape
it:
     &{This has a {braced} section.}
       â‡’ "This has a {braced} section."

   The escape character used for special characters is â€˜&â€™.  This is
compatible with XML syntax and *note XML literals::.

12.4.2.1 Special characters
...........................

     CHAR-REF ::=
         â€˜&#â€™ DIGIT^+ â€˜;â€™
       | â€˜&#xâ€™ HEX-DIGIT^+  â€˜;â€™
     ENTITY-REF ::=
         â€˜&â€™ CHAR-OR-ENTITY-NAME â€˜;â€™
     CHAR-OR-ENTITY-NAME ::= TAGNAME

   You can the standard XML syntax for character references, using
either decimal or hexadecimal values.  The following string has two
instances of the Ascii escape character, as either decimal 27 or hex 1B:
     &{&#27;&#x1B;} â‡’ "\e\e"

   You can also use the pre-defined XML entity names:
     &{&amp; &lt; &gt; &quot; &apos;} â‡’ "& < > \" '"
   In addition, â€˜&lbrace;â€™ â€˜&rbrace;â€™ can be used for left and right
curly brace, though you donâ€™t need them for balanced parentheses:
     &{ &rbrace;_&lbrace; / {_} }  â‡’ " }_{ / {_} "

   You can use the standard XML entity names
(http://www.w3.org/2003/entities/2007/w3centities-f.ent).  For example:
     &{L&aelig;rdals&oslash;yri}
       â‡’ "LÃ¦rdalsÃ¸yri"

   You can also use the standard R7RS character names â€˜nullâ€™, â€˜alarmâ€™,
â€˜backspaceâ€™, â€˜tabâ€™, â€˜newlineâ€™, â€˜returnâ€™, â€˜escapeâ€™, â€˜spaceâ€™, and
â€˜deleteâ€™.  For example:
     &{&escape;&space;}

   The syntax â€˜&NAME;â€™ is actually syntactic sugar (specifically reader
syntax) to the variable reference â€˜$entity$:NAMEâ€™.  Hence you can also
define your own entity names:
     (define $entity$:crnl "\r\n")
     &{&crnl;} âŸ¹ "\r\n"

12.4.2.2 Multiline string literals
..................................

     INITIAL-IGNORED ::=
         INTRALINE-WHITESPACE^* LINE-ENDING INTRALINE-WHITESPACE^* &|
     SPECIAL-ESCAPE ::=
         INTRALINE-WHITESPACE^* &|
       | & NESTED-COMMENT
       | &- INTRALINE-WHITESPACE^* LINE-ENDING

   A line-ending directly in the text is becomes a newline, as in a
simple string literal:
     (string-capitalize &{one two three
     uno dos tres
     }) â‡’ "One Two Three\nUno Dos Tres\n"
   However, you have extra control over layout.  If the string is in a
nested expression, it is confusing (and ugly) if the string cannot be
indented to match the surrounding context.  The indentation marker â€˜&|â€™
is used to mark the end of insignificant initial whitespace.  The â€˜&|â€™
characters and all the preceding whitespace are removed.  In addition,
it also suppresses an initial newline.  Specifically, when the initial
left-brace is followed by optional (invisible) intraline-whitespace,
then a newline, then optional intraline-whitespace (the indentation),
and finally the indentation marker â€˜&|â€™ - all of which is removed from
the output.  Otherwise the â€˜&|â€™ only removes initial
intraline-whitespace on the same line (and itself).

     (write (string-capitalize &{
          &|one two three
          &|uno dos tres
     }) out)
         â‡’ prints "One Two Three\nUno Dos Tres\n"

   As a matter of style, all of the indentation lines should line up.
It is an error if there are any non-whitespace characters between the
previous newline and the indentation marker.  It is also an error to
write an indentation marker before the first newline in the literal.

   The line-continuation marker â€˜&-â€™ is used to suppress a newline:
     &{abc&-
       def} â‡’ "abc  def"

   You can write a â€˜#|...|#â€™-style comment following a â€˜&â€™.  This could
be useful for annotation, or line numbers:
     &{&#|line 1|#one two
       &#|line 2|# three
       &#|line 3|#uno dos tres
     } â‡’ "one two\n three\nuno dos tres\n"

12.4.2.3 Embedded expressions
.............................

     ENCLOSED-PART ::=
         & enclosed-modifier [ EXPRESSION^* ]
       | & enclosed-modifier ( EXPRESSION^+ )

   An embedded expression has the form â€˜&[EXPRESSION]â€™.  It is
evaluated, the result converted to a string (as by â€˜displayâ€™), and the
result added in the result string.  (If there are multiple expressions,
they are all evaluated and the corresponding strings inserted in the
result.)
     &{Hello &[(string-capitalize name)]!}

   You can leave out the square brackets when the expression is a
parenthesized expression:
     &{Hello &(string-capitalize name)!}

12.4.2.4 Formatting
...................

     ENCLOSED-MODIFIER ::=
       ~ FORMAT-SPECIFIER-AFTER-TILDE^*

   Using *note â€˜formatâ€™: Format. allows finer-grained control over the
output, but a problem is that the association between format specifiers
and data expressions is positional, which is hard-to-read and
error-prone.  A better solution places the specifier adjacant to the
data expression:
     &{The response was &~,2f(* 100.0 (/ responses total))%.}

   The following escape forms are equivalent to the corresponding forms
withput the â€˜~â€™FMT-SPEC, except the expression(s) are formatted using
â€˜formatâ€™:
     â€˜&~â€™FMT-SPECâ€˜[â€™EXPRESSION^*â€˜]â€™
   Again using parentheses like this:
     â€˜&~â€™FMT-SPECâ€˜(â€™EXPRESSION^+â€˜)â€™
   is equivalent to:
     â€˜&~â€™FMT-SPECâ€˜[(â€™EXPRESSION^+â€˜)]â€™

   The syntax of â€˜formatâ€™ specifications is arcane, but it allows you to
do some pretty neat things in a compact space.  For example to include
â€˜"_"â€™ between each element of the array â€˜arrâ€™ you can use the â€˜~{...~}â€™
format speciers:
     (define arr [5 6 7])
     &{&~{&[arr]&~^_&~}} â‡’ "5_6_7"

   If no format is specified for an enclosed expression, the that is
equivalent to a â€˜~aâ€™ format specifier, so this is equivalent to:
     &{&~{&~a[arr]&~^_&~}} â‡’ "5_6_7"
   which is in turn equivalent to:
     (format #f "~{~a~^_~}" arr)

   The fine print that makes this work: If there are multiple
expressions in a â€˜&[...]â€™ with no format specifier then there is an
implicit â€˜~aâ€™ for each expression.  On the other hand, if there is an
explicit format specifier, it is not repeated for each enclosed
expression: it appears exactly once in the effective format string,
whether there are zero, one, or many expressions.


File: kawa.info,  Node: Unicode,  Next: Regular expressions,  Prev: String literals,  Up: Characters and text

12.5 Unicode character classes and conversions
==============================================

Some of the procedures that operate on characters or strings ignore the
difference between upper case and lower case.  These procedures have
â€˜-ciâ€™ (for â€œcase insensitiveâ€) embedded in their names.

12.5.1 Characters
-----------------

 -- Procedure: char-upcase CHAR
 -- Procedure: char-downcase CHAR
 -- Procedure: char-titlecase CHAR
 -- Procedure: char-foldcase CHAR
     These procedures take a character argument and return a character
     result.

     If the argument is an upperâ€“case or titleâ€“case character, and if
     there is a single character that is its lowerâ€“case form, then
     â€˜char-downcaseâ€™ returns that character.

     If the argument is a lowerâ€“case or titleâ€“case character, and there
     is a single character that is its upperâ€“case form, then
     â€˜char-upcaseâ€™ returns that character.

     If the argument is a lowerâ€“case or upperâ€“case character, and there
     is a single character that is its titleâ€“case form, then
     â€˜char-titlecaseâ€™ returns that character.

     If the argument is not a titleâ€“case character and there is no
     single character that is its titleâ€“case form, then â€˜char-titlecaseâ€™
     returns the upperâ€“case form of the argument.

     Finally, if the character has a caseâ€“folded character, then
     â€˜char-foldcaseâ€™ returns that character.  Otherwise the character
     returned is the same as the argument.

     For Turkic characters â€˜#\x130â€™ and â€˜#\x131â€™, â€˜char-foldcaseâ€™
     behaves as the identity function; otherwise â€˜char-foldcaseâ€™ is the
     same as â€˜char-downcaseâ€™ composed with â€˜char-upcaseâ€™.

          (char-upcase #\i)               â‡’  #\I
          (char-downcase #\i)             â‡’  #\i
          (char-titlecase #\i)            â‡’  #\I
          (char-foldcase #\i)             â‡’  #\i

          (char-upcase #\ÃŸ)               â‡’  #\ÃŸ
          (char-downcase #\ÃŸ)             â‡’  #\ÃŸ
          (char-titlecase #\ÃŸ)            â‡’  #\ÃŸ
          (char-foldcase #\ÃŸ)             â‡’  #\ÃŸ

          (char-upcase #\Î£)               â‡’  #\Î£
          (char-downcase #\Î£)             â‡’  #\Ïƒ
          (char-titlecase #\Î£)            â‡’  #\Î£
          (char-foldcase #\Î£)             â‡’  #\Ïƒ

          (char-upcase #\Ï‚)               â‡’  #\Î£
          (char-downcase #\Ï‚)             â‡’  #\Ï‚
          (char-titlecase #\Ï‚)            â‡’  #\Î£
          (char-foldcase #\Ï‚)             â‡’  #\Ïƒ

          _Note:_ â€˜char-titlecaseâ€™ does not always return a titleâ€“case
          character.

          _Note:_ These procedures are consistent with Unicodeâ€™s
          localeâ€“independent mappings from scalar values to scalar
          values for upcase, downcase, titlecase, and caseâ€“folding
          operations.  These mappings can be extracted from
          â€˜UnicodeData.txtâ€™ and â€˜CaseFolding.txtâ€™ from the Unicode
          Consortium, ignoring Turkic mappings in the latter.

          Note that these characterâ€“based procedures are an incomplete
          approximation to case conversion, even ignoring the userâ€™s
          locale.  In general, case mappings require the context of a
          string, both in arguments and in result.  The â€˜string-upcaseâ€™,
          â€˜string-downcaseâ€™, â€˜string-titlecaseâ€™, and â€˜string-foldcaseâ€™
          procedures perform more general case conversion.

 -- Procedure: char-ci=? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char-ci<? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char-ci>? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char-ci<=? CHAR1 CHAR2 CHAR3 â€¦
 -- Procedure: char-ci>=? CHAR1 CHAR2 CHAR3 â€¦
     These procedures are similar to â€˜char=?â€™, etc., but operate on the
     caseâ€“folded versions of the characters.

          (char-ci<? #\z #\Z)             â‡’ #f
          (char-ci=? #\z #\Z)             â‡’ #f
          (char-ci=? #\Ï‚ #\Ïƒ)             â‡’ #t

 -- Procedure: char-alphabetic? CHAR
 -- Procedure: char-numeric? CHAR
 -- Procedure: char-whitespace? CHAR
 -- Procedure: char-upper-case? CHAR
 -- Procedure: char-lower-case? CHAR
 -- Procedure: char-title-case? CHAR
     These procedures return â€˜#tâ€™ if their arguments are alphabetic,
     numeric, whitespace, upperâ€“case, lowerâ€“case, or titleâ€“case
     characters, respectively; otherwise they return â€˜#fâ€™.

     A character is alphabetic if it has the Unicode â€œAlphabeticâ€
     property.  A character is numeric if it has the Unicode â€œNumericâ€
     property.  A character is whitespace if has the Unicode
     â€œWhite_Spaceâ€ property.  A character is upper case if it has the
     Unicode â€œUppercaseâ€ property, lower case if it has the â€œLowercaseâ€
     property, and title case if it is in the Lt general category.

          (char-alphabetic? #\a)          â‡’  #t
          (char-numeric? #\1)             â‡’  #t
          (char-whitespace? #\space)      â‡’  #t
          (char-whitespace? #\x00A0)      â‡’  #t
          (char-upper-case? #\Î£)          â‡’  #t
          (char-lower-case? #\Ïƒ)          â‡’  #t
          (char-lower-case? #\x00AA)      â‡’  #t
          (char-title-case? #\I)          â‡’  #f
          (char-title-case? #\x01C5)      â‡’  #t

 -- Procedure: char-general-category CHAR
     Return a symbol representing the Unicode general category of CHAR,
     one of â€˜Luâ€™, â€˜Llâ€™, â€˜Ltâ€™, â€˜Lmâ€™, â€˜Loâ€™, â€˜Mnâ€™, â€˜Mcâ€™, â€˜Meâ€™, â€˜Ndâ€™, â€˜Nlâ€™,
     â€˜Noâ€™, â€˜Psâ€™, â€˜Peâ€™, â€˜Piâ€™, â€˜Pfâ€™, â€˜Pdâ€™, â€˜Pcâ€™, â€˜Poâ€™, â€˜Scâ€™, â€˜Smâ€™, â€˜Skâ€™,
     â€˜Soâ€™, â€˜Zsâ€™, â€˜Zpâ€™, â€˜Zlâ€™, â€˜Ccâ€™, â€˜Cfâ€™, â€˜Csâ€™, â€˜Coâ€™, or â€˜Cnâ€™.

          (char-general-category #\a)         â‡’ Ll
          (char-general-category #\space)     â‡’ Zs
          (char-general-category #\x10FFFF)   â‡’ Cn

12.5.2 Deprecated in-place case modification
--------------------------------------------

The following functions are deprecated; they really donâ€™t and cannot do
the right thing, because in some languages upper and lower case can use
different number of characters.

 -- Procedure: string-upcase! str
     _Deprecated:_ Destructively modify STR, replacing the letters by
     their upper-case equivalents.

 -- Procedure: string-downcase! str
     _Deprecated:_ Destructively modify STR, replacing the letters by
     their upper-lower equivalents.

 -- Procedure: string-capitalize! str
     _Deprecated:_ Destructively modify STR, such that the letters that
     start a new word are replaced by their title-case equivalents,
     while non-initial letters are replaced by their lower-case
     equivalents.


File: kawa.info,  Node: Regular expressions,  Prev: Unicode,  Up: Characters and text

12.6 Regular expressions
========================

Kawa provides "regular expressions", which is a convenient mechanism for
matching a string against a "pattern" and maybe replacing matching
parts.

   A regexp is a string that describes a pattern.  A regexp matcher
tries to match this pattern against (a portion of) another string, which
we will call the text string.  The text string is treated as raw text
and not as a pattern.

   Most of the characters in a regexp pattern are meant to match
occurrences of themselves in the text string.  Thus, the pattern â€œâ€˜abcâ€™â€
matches a string that contains the characters â€œâ€˜aâ€™â€, â€œâ€˜bâ€™â€, â€œâ€˜câ€™â€ in
succession.

   In the regexp pattern, some characters act as "metacharacters", and
some character sequences act as "metasequences".  That is, they specify
something other than their literal selves.  For example, in the pattern
â€œâ€˜a.câ€™â€, the characters â€œâ€˜aâ€™â€ and â€œâ€˜câ€™â€ do stand for themselves but the
metacharacter â€œâ€˜.â€™â€ can match any character (other than newline).
Therefore, the pattern â€œâ€˜a.câ€™â€ matches an â€œâ€˜aâ€™â€, followed by any
character, followed by a â€œâ€˜câ€™â€.

   If we needed to match the character â€œâ€˜.â€™â€ itself, we "escape" it, ie,
precede it with a backslash â€œâ€˜\â€™â€.  The character sequence â€œâ€˜\.â€™â€ is
thus a metasequence, since it doesnâ€™t match itself but rather just
â€œâ€˜.â€™â€.  So, to match â€œâ€˜aâ€™â€ followed by a literal â€œâ€˜.â€™â€ followed by â€œâ€˜câ€™â€
we use the regexp pattern â€œâ€˜a\.câ€™â€.  To write this as a Scheme string
literal, you need to quote the backslash, so you need to write
â€˜"a\\.c"â€™.  Kawa also allows the literal syntax â€˜#/a\.c/â€™, which avoids
the need to double the backslashes.

   You can choose between two similar styles of regular expressions.
The two differ slightly in terms of which characters act as
metacharacters, and what those metacharacters mean:
   â€¢ Functions starting with â€˜regex-â€™ are implemented using the
     â€˜java.util.regexâ€™ package.  This is likely to be more efficient,
     has better Unicode support and some other minor extra features, and
     literal syntax â€˜#/a\.c/â€™ mentioned above.
   â€¢ Functions starting with â€˜pregexp-â€™ are implemented in pure Scheme
     using Dorai Sitaramâ€™s â€œPortable Regular Expressions for Schemeâ€
     library.  These will be portable to more Scheme implementations,
     including BRL, and is available on older Java versions.

12.6.1 Java regular expressions
-------------------------------

The syntax for regular expressions is documented here
(http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html).

 -- Type: regex
     A compiled regular expression, implemented as
     â€˜java.util.regex.Patternâ€™.

 -- Constructor: regex arg
     Given a regular expression pattern (as a string), compiles it to a
     â€˜regexâ€™ object.

          (regex "a\\.c")
     This compiles into a pattern that matches an â€œâ€˜aâ€™â€, followed by any
     character, followed by a â€œâ€˜câ€™â€.

   The Scheme reader recognizes â€œâ€˜#/â€™â€ as the start of a regular
expression "pattern literal", which ends with the next un-escaped â€œâ€˜/â€™â€.
This has the big advantage that you donâ€™t need to double the
backslashes:
     #/a\.c/
   This is equivalent to â€˜(regex "a\\.c")â€™, except it is compiled at
read-time.  If you need a literal â€œâ€˜/â€™â€ in a pattern, just escape it
with a backslash: â€œâ€˜#/a\/c/â€™â€ matches a â€œâ€˜aâ€™â€, followed by a â€œâ€˜/â€™â€,
followed by a â€œâ€˜câ€™â€.

   You can add single-letter _modifiers_ following the pattern literal.
The following modifiers are allowed:
â€˜iâ€™
     The modifier â€œâ€˜iâ€™â€ cause the matching to ignore case.  For example
     the following pattern matches â€œâ€˜aâ€™â€ or â€œâ€˜Aâ€™â€.
          #/a/i
â€˜mâ€™
     Enables â€œmetalineâ€ mode.  Normally metacharacters â€œâ€˜^â€™â€ and â€œâ€˜$â€™â€™
     match at the start end end of the entire input string.  In metaline
     mode â€œâ€˜^â€™â€ and â€œâ€˜$â€™â€ also match just before or after a line
     terminator.

     Multiline mode can also be enabled by the metasequence â€œâ€˜(?m)â€™â€.
â€˜sâ€™
     Enable â€œsinglelineâ€ (aka â€œdot-allâ€) mode.  In this mode the
     matacharacter â€œâ€˜.â€™ matches any character, including a line breaks.
     This mode be enabled by the metasequence â€œâ€˜(?s)â€™â€.

   The following functions accept a regex either as a pattern string or
a compiled â€˜regexâ€™ pattern.  I.e.  the following are all equivalent:
     (regex-match "b\\.c" "ab.cd")
     (regex-match #/b\.c/ "ab.cd")
     (regex-match (regex "b\\.c") "ab.cd")
     (regex-match (java.util.regex.Pattern:compile "b\\.c") "ab.cd")
   These all evaluate to the list â€˜("b.c")â€™.

   The following functions must be imported by doing one of:
     (require 'regex) ;; or
     (import (kawa regex))

 -- Procedure: regex-match-positions regex string [start [end]]

     The procedure â€˜regexâ€‘matchâ€‘positionâ€™ takes pattern and a text
     STRING, and returns a match if the regex matches (some part of) the
     text string.

     Returns â€˜#fâ€™ if the regexp did not match the string; and a list of
     index pairs if it did match.
          (regex-match-positions "brain" "bird") â‡’ #f
          (regex-match-positions "needle" "hay needle stack")
            â‡’ ((4 . 10))

     In the second example, the integers 4 and 10 identify the substring
     that was matched.  4 is the starting (inclusive) index and 10 the
     ending (exclusive) index of the matching substring.

          (substring "hay needle stack" 4 10) â‡’ "needle"

     In this case the return list contains only one index pair, and that
     pair represents the entire substring matched by the regexp.  When
     we discuss subpatterns later, we will see how a single match
     operation can yield a list of submatches.

     â€˜regexâ€‘matchâ€‘positionsâ€™ takes optional third and fourth arguments
     that specify the indices of the text string within which the
     matching should take place.

          (regex-match-positions "needle"
            "his hay needle stack -- my hay needle stack -- her hay needle stack"
            24 43)
            â‡’ ((31 . 37))

     Note that the returned indices are still reckoned relative to the
     full text string.

 -- Procedure: regex-match regex string [start [end]]
     The procedure â€˜regexâ€‘matchâ€™ is called like â€˜regexâ€‘matchâ€‘positionsâ€™
     but instead of returning index pairs it returns the matching
     substrings:
          (regex-match "brain" "bird") â‡’ #f
          (regex-match "needle" "hay needle stack")
            â‡’ ("needle")

     â€˜regexâ€‘matchâ€™ also takes optional third and fourth arguments, with
     the same meaning as does â€˜regexâ€‘matchâ€‘positionsâ€™.

 -- Procedure: regex-split regex string
     Takes two arguments, a REGEX pattern and a text STRING, and returns
     a list of substrings of the text string, where the pattern
     identifies the delimiter separating the substrings.
          (regex-split ":" "/bin:/usr/bin:/usr/bin/X11:/usr/local/bin")
            â‡’ ("/bin" "/usr/bin" "/usr/bin/X11" "/usr/local/bin")

          (regex-split " " "pea soup")
            â‡’ ("pea" "soup")

     If the first argument can match an empty string, then the list of
     all the single-character substrings is returned, plus we get a
     empty strings at each end.

          (regex-split "" "smithereens")
            â‡’ ("" "s" "m" "i" "t" "h" "e" "r" "e" "e" "n" "s" "")

     (Note: This behavior is different from â€˜pregexp-splitâ€™.)

     To identify one-or-more spaces as the delimiter, take care to use
     the regexp â€œâ€˜ +â€™â€, not â€œâ€˜ *â€™â€.
          (regex-split " +" "split pea     soup")
            â‡’ ("split" "pea" "soup")
          (regex-split " *" "split pea     soup")
            â‡’ ("" "s" "p" "l" "i" "t" "" "p" "e" "a" "" "s" "o" "u" "p" "")

 -- Procedure: regexâ€‘replace regex string replacement
     Replaces the matched portion of the text STRING by another a
     REPLACDEMENT string.
          (regex-replace "te" "liberte" "ty")
            â‡’ "liberty"

     Submatches can be used in the replacement string argument.  The
     replacement string can use â€œâ€˜$Nâ€™â€ as a "backreference" to refer
     back to the Nth submatch, ie, the substring that matched the Nth
     subpattern.  â€œâ€˜$0â€™â€ refers to the entire match.
          (regex-replace #/_(.+?)_/
                         "the _nina_, the _pinta_, and the _santa maria_"
          		"*$1*"))
            â‡’ "the *nina*, the _pinta_, and the _santa maria_"

 -- Procedure: regexâ€‘replace* regex string replacement
     Replaces all matches in the text STRING by the REPLACEMENT string:
          (regex-replace* "te" "liberte egalite fraternite" "ty")
            â‡’ "liberty egality fratyrnity"
          (regex-replace* #/_(.+?)_/
                          "the _nina_, the _pinta_, and the _santa maria_"
                          "*$1*")
            â‡’ "the *nina*, the *pinta*, and the *santa maria*"

 -- Procedure: regex-quote pattern
     Takes an arbitrary string and returns a pattern string that
     precisely matches it.  In particular, characters in the input
     string that could serve as regex metacharacters are escaped as
     needed.

          (regex-quote "cons")
            â‡’ "\Qcons\E"
     â€˜regexâ€‘quoteâ€™ is useful when building a composite regex from a mix
     of regex strings and verbatim strings.

12.6.2 Portable Scheme regular expressions
------------------------------------------

This provides the procedures â€˜pregexpâ€™, â€˜pregexpâ€‘matchâ€‘positionsâ€™,
â€˜pregexpâ€‘matchâ€™, â€˜pregexpâ€‘splitâ€™, â€˜pregexpâ€‘replaceâ€™, â€˜pregexpâ€‘replace*â€™,
and â€˜pregexpâ€‘quoteâ€™.

   Before using them, you must require them:
     (require 'pregexp)

   These procedures have the same interface as the corresponding
â€˜regex-â€™ versions, but take slightly different pattern syntax.  The
replace commands use â€œâ€˜\â€™â€ instead of â€œâ€˜$â€™â€ to indicate substitutions.
Also, â€˜pregexpâ€‘splitâ€™ behaves differently from â€˜regexâ€‘splitâ€™ if the
pattern can match an empty string.

   See here for details
(http://www.ccs.neu.edu/home/dorai/pregexp/index.html).


File: kawa.info,  Node: Data structures,  Next: Eval and Environments,  Prev: Characters and text,  Up: Top

13 Data structures
******************

* Menu:

* Sequences::
* Lists::
* Vectors::
* Uniform vectors::
* Bytevectors::
* Streams:: Lazy lists.
* Arrays::  Multi-dimensional Arrays
* Hash tables::


File: kawa.info,  Node: Sequences,  Next: Lists,  Up: Data structures

13.1 Sequences
==============

A "sequence" is a generalized list, consisting of zero or more values.
You can choose between a number of different kinds of sequence
implementations.  Scheme traditionally has *note lists: Lists. and *note
vectors: Vectors.  Any Java class that implements â€˜java.util.Listâ€™ is a
sequence type.  Raw Java arrays can also be viewerd as a sequence, and
strings can be viewed a sequence (or vector) of characters.  Kawa also
provides *note uniform vectors: Uniform vectors.

   Sequence types differ in their API, but given a sequence type STYPE
you can construct instances of that types using the syntax:
     (STYPE V0 V1 .... VN)
   For example:
     (bytevector 9 8 7 6)  â‡’ #u8(9 8 7 6)

   For a raw Java class name JNAME you may need to use the empty keyword
â€˜||:â€™ to separate constructor parameters (if any) from sequence
elements, as in:
     (gnu.lists.U8Vector ||: 9 8 7 6)  â‡’ #u8(9 8 7 6)
   This syntax works with any type with a default constructor and a
1-argument â€˜addâ€™ method; see *note Allocating objects:: for details.
You can use the same syntax for allocating arrays, though array creation
supports *note more options: Creating-new-Java-arrays.

   To extract an element from Scheme sequence of type STYPE there is
usually a function â€˜STYPE-refâ€™.  For example:
     (define vec1 (vector 5 6 7 8))
     (vector-ref vec1 2) â‡’ 7
   More concisely, you can use (Kawa-specific) function call syntax:
     (vec1 3) â‡’ 8
   The same function call syntax also works for raw Java arrays:
     (define arr1 (long[] 4 5 6 7))
     (arr1 3) â‡’ 7

   To assign to (replace) an element from a sequence of Scheme type
STYPE there is usually a function â€˜STYPE-set!â€™:
     (vector-set! vec1 1 9)
     vec1 â‡’ #(5 9 7 8)

   Again, you can use the function call syntax:
     (set! (vec1 2) 'x)
     vec1 â‡’ #(5 9 x 8)

 -- Procedure: length seq
     Returns the number of elements of the SEQ.

          (length '(a b c))             â‡’  3
          (length '(a (b) (c d e)))     â‡’  3
          (length '())                  â‡’  0
          (length [3 4 [] 12])          â‡’  4
          (length (vector))             â‡’  0
          (length (int[] 7 6))          â‡’  2

     The length of a string is the number of 16-bit code units, not the
     number the code points.  That is the result of the
     â€˜java.lang.CharSequence#lengthâ€™ method, not the â€˜string-lengthâ€™
     procedure.
          (length "Hello")              â‡’  5
          (define str1 "Hello \x1f603;!")
          (invoke str1 'length)         â‡’  9
          (length str1)                 â‡’  9
          (string-length str1)          â‡’  8


File: kawa.info,  Node: Lists,  Next: Vectors,  Prev: Sequences,  Up: Data structures

13.2 Lists
==========

A pair (sometimes called a "dotted pair") is a record structure with two
fields called the car and cdr fields (for historical reasons).  Pairs
are created by the procedure â€˜consâ€™.  The car and cdr fields are
accessed by the procedures â€˜carâ€™ and â€˜cdrâ€™.  The car and cdr fields are
assigned by the procedures â€˜set-car!â€™ and â€˜set-cdr!â€™.

   Pairs are used primarily to represent lists.  A "list" can be defined
recursively as either the empty list or a pair whose cdr is a list.
More precisely, the set of lists is defined as the smallest set X such
that:
   â€¢ The empty list is in X.
   â€¢ If LIST is in X, then any pair whose cdr field contains LIST is
     also in X.

   The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose
car is the first element and whose cdr is a pair whose car is the second
element and whose cdr is the empty list.  The length of a list is the
number of elements, which is the same as the number of pairs.

   The empty list is a special object of its own type.  It is not a
pair, it has no elements, and its length is zero.

   _Note:_ The above definitions imply that all lists have finite length
and are terminated by the empty list.

   The most general notation (external representation) for Scheme pairs
is the â€œdottedâ€ notation â€˜(C1 . C2 )â€™ where C1 is the value of the car
field and C2 is the value of the cdr field.  For example â€˜(4 . 5)â€™ is a
pair whose car is 4 and whose cdr is 5.  Note that â€˜(4 . 5)â€™ is the
external representation of a pair, not an expression that evaluates to a
pair.

   A more streamlined notation can be used for lists: the elements of
the list are simply enclosed in parentheses and separated by spaces.
The empty list is written â€˜()â€™.  For example,
     (a b c d e)
   and
     (a . (b . (c . (d . (e . ())))))
   are equivalent notations for a list of symbols.

   A chain of pairs not ending in the empty list is called an "improper
list".  Note that an improper list is not a list.  The list and dotted
notations can be combined to represent improper lists:
     (a b c . d)
   is equivalent to
     (a . (b . (c . d)))

   _Needs to finish merging from R7RS!_

 -- Procedure: make-list k [fill]
     Returns a newly allocated list of K elements.  If a second argument
     is given, the each element is initialized to FILL.  Otherwise the
     initial contents of each element is unspecified.
          (make-list 2 3)   â‡’ (3 3)

13.2.1 SRFI-1 list library
--------------------------

The SRFI-1 List Library (http://srfi.schemers.org/srfi-1/srfi-1.html) is
available, though not enabled by default.  To use its functions you must
â€˜(require 'list-lib)â€™ or â€˜(require 'srfi-1)â€™.
     (require 'list-lib)
     (iota 5 0 -0.5) â‡’ (0.0 -0.5 -1.0 -1.5 -2.0)

 -- Procedure: reverse! list
     The result is a list consisting of the elements of LIST in reverse
     order.  No new pairs are allocated, instead the pairs of LIST are
     re-used, with â€˜cdrâ€™ cells of LIST reversed in place.  Note that if
     LIST was pair, it becomes the last pair of the reversed result.

13.2.2 SRFI-101 Purely Functional Random-Access Pairs and Lists
---------------------------------------------------------------

SRFI-101 (http://srfi.schemers.org/srfi-101/srfi-101.html) specifies
immutable (read-only) lists with fast (logarithmic) indexing and
functional update (i.e.  return a modified list).  These are implemented
by a â€˜RAPairâ€™ class which extends the generic â€˜pairâ€™ type, which means
that most code that expects a standard list will work on these lists as
well.


File: kawa.info,  Node: Vectors,  Next: Uniform vectors,  Prev: Lists,  Up: Data structures

13.3 Vectors
============

Vectors are heterogeneous structures whose elements are indexed by
integers.  A vector typically occupies less space than a list of the
same length, and the average time needed to access a randomly chosen
element is typically less for the vector than for the list.

   The _length_ of a vector is the number of elements that it contains.
This number is a nonâ€“negative integer that is fixed when the vector is
created.  The _valid indices_ of a vector are the exact nonâ€“negative
integer objects less than the length of the vector.  The first element
in a vector is indexed by zero, and the last element is indexed by one
less than the length of the vector.

   Vectors are written using the notation â€˜#(OBJ ...)â€™.  For example, a
vector of length 3 3 containing the number zero in element 0, the list
â€˜(2 2 2 2)â€™ in element 1, and the string â€˜"Anna"â€™ in element 2 can be
written as following:
     #(0 (2 2 2 2) "Anna")
   Note that this is the external representation of a vector.  In Kawa,
a vector datum is self-evaluating, but for style (and compatibility with
R7RS) is is suggested you quote a vector constant:
     â€™#(0 (2 2 2 2) "Anna")  â‡’ #(0 (2 2 2 2) "Anna")

   Compare these different ways of creating a vector:
â€˜(vector a b c)â€™
     In this case â€˜aâ€™, â€˜bâ€™, and â€˜câ€™ are expressions evaluated at
     run-time and the results used to initialize a newly-allocated
     3-element vector.
â€˜[a b c]â€™
     Same as using vector, but more concise, and results in an immutable
     (non-modifiable) vector.
â€˜#(a b c)â€™
     This is reader syntax and creates a vector literal, at read-time,
     early in compile-time.  The symbols â€˜aâ€™, â€˜bâ€™, and â€˜câ€™ are not
     evaluated but instead used literally.
â€˜`#(,a ,b ,c)â€™
     This is reader-syntax, using quasi-quotation, so â€˜aâ€™, â€˜bâ€™, and â€˜câ€™
     are expressions evaluated at run-time.  This is equivalent to â€˜[a b
     c]â€™ in that it results in an immutable vector.

 -- Type: vector
     The type of vector objects.

 -- Constructor: vector OBJ â€¦
     Return a newly allocated vector whose elements contain the given
     arguments.  Analogous to â€˜listâ€™.

          (vector 'a 'b 'c)               â‡’  #(a b c)

     Alternatively, you can use square-bracket syntax, which results in
     an immutable vector:
          ['a 'b 'c]               â‡’  #(a b c)

 -- Procedure: make-vector K
 -- Procedure: make-vector K FILL
     Return a newly allocated vector of K elements.  If a second
     argument is given, then each element is initialized to FILL.
     Otherwise the initial contents of each element is â€˜#!nullâ€™.

 -- Procedure: vector? OBJ
     Return â€˜#tâ€™ if OBJ is a vector, â€˜#fâ€™ otherwise.

 -- Procedure: vector-length VECTOR
     Return the number of elements in VECTOR as an exact integer.

 -- Procedure: vector-ref VECTOR K
     It is an error if K is not a valid index of VECTOR.  The
     â€˜vector-refâ€™ procedure returns the contents of element K of VECTOR.

          (vector-ref '#(1 1 2 3 5 8 13 21) 5)     â‡’  8
          (vector-ref '#(1 1 2 3 5 8 13 21)
            (inexact->exact (round (* 2 (acos -1)))))
          â‡’ 13

 -- Procedure: vector-set! VECTOR K OBJ
     It is an error if K is not a valid index of VECTOR.  The
     â€˜vector-set!â€™ procedure stores OBJ in element K of VECTOR, and
     returns no values.

          (let ((vec (vector 0 '(2 2 2 2) "Anna")))
            (vector-set! vec 1 '("Sue" "Sue"))
            vec)
            â‡’  #(0 ("Sue" "Sue") "Anna")

          (vector-set! '#(0 1 2) 1 "doe")
            â‡’  error    ;; constant vector

   A concise alternative to â€˜vector-refâ€™ and â€˜vector-set!â€™ is to use
function call syntax.  For example:
     (let ((vec (vector 0 '(2 2 2 2) "Anna")))
       (set! (vec 1) '("Sue" "Sue"))
       (list (vec 2) (vec 1)))
       â‡’  ("Anna" ("Sue" "Sue"))

 -- Procedure: vector->list VECTOR [START [END]]
     The â€˜vector->listâ€™ procedure returns a newly allocated list of the
     objects contained in the elements of VECTOR between START and END.

          (vector->list '#(dah dah didah))        â‡’  (dah dah didah)
          (vector->list '#(dah dah didah) 1 2)    â‡’  (dah)

 -- Procedure: list->vector LIST
     The â€˜list->vectorâ€™ procedure returns a newly created vector
     initialized to the elements of the list LIST, in order.
          (list->vector '(dididit dah))           â‡’  #(dididit dah)

 -- Procedure: vector->string vector [start [end]]
     The â€˜vector->stringâ€™ procedure returns a newly allocated string of
     the objects contained in the elements of VECTOR between START and
     END.  It is an error if any element of VECTOR between START and END
     is not a character, or is a character forbidden in strings.
          (vector->string #(#\1 #\2 #\3))             â‡’ "123"
          (vector->string #(#\1 #\2 #\3 #\4 #\5) 2 4) â‡’ "34"

 -- Procedure: string->vector string [start [end]]
     The â€˜string->vectorâ€™ procedure returns a newly created vector
     initialized to the elements of the string STRING between START and
     END.
          (string->vector "ABC")       â‡’ #(#\A #\B #\C)
          (string->vector "ABCDE" 1 3) â‡’ #(#\B #\C)

 -- Procedure: vector-copy vector [start [end]]
     Returns a newly allocated copy of the elements of the given VECTOR
     between START and END .  The elements of the new vector are the
     same (in the sense of â€˜eqv?â€™) as the elements of the old.

          (define a #(1 8 2 8)) ; a may be immutable
          (define b (vector-copy a))
          (vector-set! b 0 3)   ; b is mutable
          b                     â‡’      #(3 8 2 8)
          (define c (vector-copy b 1 3))
          c                     â‡’ #(8 2)

 -- Procedure: vector-copy! to at from [start [end]]
     Copies the elements of vector from between start and end to vector
     to, starting at at.  The order in which elements are copied is
     unspecified, except that if the source and destination overlap,
     copying takes place as if the source is first copied into a
     temporary vector and then into the destination.  This can be
     achieved without allocating storage by making sure to copy in the
     correct direction in such circumstances.

     It is an error if AT is less than zero or greater than the length
     of TO.  It is also an error if â€˜(- (vector-length TO) AT)â€™ is less
     than â€˜(- END START)â€™.

          (define a (vector 1 2 3 4 5))
          (define b (vector 10 20 30 40 50))
          (vector-copy! b 1 a 0 2)
          b    â‡’ #(10 1 2 40 50)

 -- Procedure: vector-append ARG...
     Creates a newly allocated vector whose elements are the
     concatenation of the elements of the given arguments.  Each ARG may
     be a vector or a list.
          (vector-append #(a b c) #(d e f))
              â‡’ #(a b c d e f)

 -- Procedure: vector-fill! VECTOR FILL [START [END]]
     Stores FILL in in the elements of VECTOR between START and END.
          (define a (vector 1 2 3 4 5))
          (vector-fill! a 'smash 2 4)
          a  â‡’ #(1 2 smash smash 5)

 -- Procedure: vector-map PROC VECTOR1 VECTOR2 â€¦
     The VECTORs must all have the same length.  PROC should accept as
     many arguments as there are VECTORs and return a single value.

     The â€˜vector-mapâ€™ procedure applies PROC elementâ€“wise to the
     elements of the VECTORs and returns a vector of the results, in
     order.  PROC is always called in the same dynamic environment as
     â€˜vector-mapâ€™ itself.  The order in which PROC is applied to the
     elements of the VECTORs is unspecified.  If multiple returns occur
     from â€˜vector-mapâ€™, the return values returned by earlier returns
     are not mutated.

     Analogous to â€˜mapâ€™.

 -- Procedure: vector-for-each PROC VECTOR1 VECTOR2 â€¦
     The VECTORs must all have the same length.  PROC should accept as
     many arguments as there are VECTORs.  The â€˜vector-for-eachâ€™
     procedure applies PROC elementâ€“wise to the elements of the VECTORs
     for its side effects, in order from the first elements to the last.
     PROC is always called in the same dynamic environment as
     â€˜vector-for-eachâ€™ itself.  The return values of â€˜vector-for-eachâ€™
     are unspecified.

     Analogous to â€˜for-eachâ€™.


File: kawa.info,  Node: Uniform vectors,  Next: Bytevectors,  Prev: Vectors,  Up: Data structures

13.4 Uniform vectors
====================

Uniform vectors are vectors whose elements are of the same numeric type.
The are defined by SRFI-4 (http://srfi.schemers.org/srfi-4/srfi-4.html).
The type names (such as â€˜s8vectorâ€™) are a Kawa extension.

 -- Type: s8vector
     The type of uniform vectors where each element can contain a signed
     8-bit integer.  Represented using an array of â€˜byteâ€™.

 -- Type: u8vector
     The type of uniform vectors where each element can contain an
     unsigned 8-bit integer.  Represented using an array of â€˜<byte>â€™,
     but each element is treated as if unsigned.

     This type is a synonym for â€˜bytevectorâ€™, which has *note extra
     functions: Bytevectors.

 -- Type: s16vector
     The type of uniform vectors where each element can contain a signed
     16-bit integer.  Represented using an array of â€˜shortâ€™.

 -- Type: u16vector
     The type of uniform vectors where each element can contain an
     unsigned 16-bit integer.  Represented using an array of â€˜shortâ€™,
     but each element is treated as if unsigned.

 -- Type: s32vector
     The type of uniform vectors where each element can contain a signed
     32-bit integer.  Represented using an array of â€˜intâ€™.

 -- Type: u32vector
     The type of uniform vectors where each element can contain an
     unsigned 32-bit integer.  Represented using an array of â€˜intâ€™, but
     each element is treated as if unsigned.

 -- Type: s64vector
     The type of uniform vectors where each element can contain a signed
     64-bit integer.  Represented using an array of â€˜longâ€™.

 -- Type: u64vector
     The type of uniform vectors where each element can contain an
     unsigned 64-bit integer.  Represented using an array of â€˜longâ€™, but
     each element is treated as if unsigned.

 -- Type: f32vector
     The type of uniform vectors where each element can contain a 32-bit
     floating-point real.  Represented using an array of â€˜floatâ€™.

 -- Type: f64vector
     The type of uniform vectors where each element can contain a 64-bit
     floating-point real.  Represented using an array of â€˜doubleâ€™.

 -- Procedure: s8vector? value
 -- Procedure: u8vector? value
 -- Procedure: s16vector? value
 -- Procedure: u16vector? value
 -- Procedure: s32vector? value
 -- Procedure: u32vector? value
 -- Procedure: s64vector? value
 -- Procedure: u64vector? value
 -- Procedure: f32vector? value
 -- Procedure: f64vector? value
     Return true iff VALUE is a uniform vector of the specified type.

 -- Procedure: make-s8vector n [value]
 -- Procedure: make-u8vector n [value]
 -- Procedure: make-s16vector n [value]
 -- Procedure: make-u16vector n [value]
 -- Procedure: make-s32vector n [value]
 -- Procedure: make-u32vector n [value]
 -- Procedure: make-s64vector n [value]
 -- Procedure: make-u64vector n [value]
 -- Procedure: make-f32vector n [value]
 -- Procedure: make-f64vector n [value]
     Create a new uniform vector of the specified type, having room for
     N elements.  Initialize each element to VALUE if it is specified;
     zero otherwise.

 -- Constructor: s8vector value ...
 -- Constructor: u8vector value ...
 -- Constructor: s16vector value ..
 -- Constructor: u16vector value ...
 -- Constructor: s32vector value ...
 -- Constructor: u32vector value ...
 -- Constructor: s64vector value ...
 -- Constructor: u64vector value ...
 -- Constructor: f32vector value ...
 -- Constructor: f64vector value ...
     Create a new uniform vector of the specified type, whose length is
     the number of VALUEs specified, and initialize it using those
     VALUEs.

 -- Procedure: s8vector-length v
 -- Procedure: u8vector-length v
 -- Procedure: s16vector-length v
 -- Procedure: u16vector-length v
 -- Procedure: s32vector-length v
 -- Procedure: u32vector-length v
 -- Procedure: s64vector-length v
 -- Procedure: u64vector-length v
 -- Procedure: f32vector-length v
 -- Procedure: f64vector-length v
     Return the length (in number of elements) of the uniform vector V.

 -- Procedure: s8vector-ref v i
 -- Procedure: u8vector-ref v i
 -- Procedure: s16vector-ref v i
 -- Procedure: u16vector-ref v i
 -- Procedure: s32vector-ref v i
 -- Procedure: u32vector-ref v i
 -- Procedure: s64vector-ref v i
 -- Procedure: u64vector-ref v i
 -- Procedure: f32vector-ref v i
 -- Procedure: f64vector-ref v i
     Return the element at index I of the uniform vector V.

 -- Procedure: s8vector-set! v i x
 -- Procedure: u8vector-set! v i x
 -- Procedure: s16vector-set! v i x
 -- Procedure: u16vector-set! v i x
 -- Procedure: s32vector-set! v i x
 -- Procedure: u32vector-set! v i x
 -- Procedure: s64vector-set! v i x
 -- Procedure: u64vector-set! v i x
 -- Procedure: f32vector-set! v i x
 -- Procedure: f64vector-set! v i x
     Set the element at index I of uniform vector V to the value X,
     which must be a number coercible to the appropriate type.

 -- Procedure: s8vector->list v
 -- Procedure: u8vector->list v
 -- Procedure: s16vector->list v
 -- Procedure: u16vector->list v
 -- Procedure: s32vector->list v
 -- Procedure: u32vector->list v
 -- Procedure: s64vector->list v
 -- Procedure: u64vector->list v
 -- Procedure: f32vector->list v
 -- Procedure: f64vector->list v
     Convert the uniform vetor V to a list containing the elments of V.

 -- Procedure: list->s8vector l
 -- Procedure: list->u8vector l
 -- Procedure: list->s16vector l
 -- Procedure: list->u16vector l
 -- Procedure: list->s32vector l
 -- Procedure: list->u32vector l
 -- Procedure: list->s64vector l
 -- Procedure: list->u64vector l
 -- Procedure: list->f32vector l
 -- Procedure: list->f64vector l
     Create a uniform vector of the appropriate type, initializing it
     with the elements of the list L.  The elements of L must be numbers
     coercible the new vectorâ€™s element type.

13.4.1 Relationship with Java arrays
------------------------------------

Each uniform array type is implemented as an "underlying Java array",
and a length field.  The underlying type is â€˜byte[]â€™ for â€˜u8vectorâ€™ or
â€˜s8vectorâ€™; â€˜short[]â€™ for â€˜u16vectorâ€™ or â€˜u16vectorâ€™; â€˜int[]â€™ for
â€˜u32vectorâ€™ or â€˜s32vectorâ€™; â€˜long[]â€™ for â€˜u64vectorâ€™ or â€˜s64vectorâ€™;
â€˜float[]â€™ for â€˜f32vectorâ€™; and â€˜double[]â€™ for â€˜f32vectorâ€™.  The length
field allows a uniform array to only use the initial part of the
underlying array.  (This can be used to support Common Lispâ€™s fill
pointer feature.)  This also allows resizing a uniform vector.  There is
no Scheme function for this, but you can use the â€˜setSizeâ€™ method:
     (invoke some-vector 'setSize 200)

   If you have a Java array, you can create a uniform vector sharing
with the Java array:
     (define arr :: byte[] ((primitive-array-new byte) 10))
     (define vec :: u8vector (make u8vector arr))
   At this point â€˜vecâ€™ uses â€˜arrâ€™ for its underlying storage, so changes
to one affect the other.  It â€˜vecâ€™ is re-sized so it needs a larger
underlying array, then it will no longer use â€˜arrâ€™.


File: kawa.info,  Node: Bytevectors,  Next: Streams,  Prev: Uniform vectors,  Up: Data structures

13.5 Bytevectors
================

"Bytevectors" represent blocks of binary data.  They are fixed-length
sequences of bytes, where a BYTE is an exact integer in the range [0,
255].  A bytevector is typically more space-efficient than a vector
containing the same values.

   The length of a bytevector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
bytevector is created.  The valid indexes of a bytevector are the exact
non-negative integers less than the length of the bytevector, starting
at index zero as with vectors.

   The â€˜bytevectorâ€™ type is equivalent to the â€˜u8vectorâ€™ *note uniform
vector: Uniform vectors. type, but is specified by the R7RS standard.

   Bytevectors are written using the notation â€˜#u8(byte . . . )â€™.  For
example, a bytevector of length 3 containing the byte 0 in element 0,
the byte 10 in element 1, and the byte 5 in element 2 can be written as
following:
     #u8(0 10 5)
   Bytevector constants are self-evaluating, so they do not need to be
quoted in programs.

 -- Type: bytevector
     The type of bytevector objects.

 -- Constructor: bytevector BYTE â€¦
     Return a newly allocated bytevector whose elements contain the
     given arguments.  Analogous to â€˜vectorâ€™.
          (bytevector 1 3 5 1 3 5)  â‡’  #u8(1 3 5 1 3 5)
          (bytevector)  â‡’  #u8()

 -- Procedure: bytevector? OBJ
     Return â€˜#tâ€™ if OBJ is a bytevector, â€˜#fâ€™ otherwise.

 -- Procedure: make-bytevector k
 -- Procedure: make-bytevector k byte
     The â€˜make-bytevectorâ€™ procedure returns a newly allocated
     bytevector of length K.  If BYTE is given, then all elements of the
     bytevector are initialized to BYTE, otherwise the contents of each
     element are unspecified.
          (make-bytevector 2 12) â‡’ #u8(12 12)

 -- Procedure: bytevector-length bytevector
     Returns the length of BYTEVECTOR in bytes as an exact integer.

 -- Procedure: bytevector-u8-ref bytevector k
     It is an error if K is not a valid index of BYTEVECTOR.  Returns
     the Kth byte of BYTEVECTOR.
          (bytevector-u8-ref â€™#u8(1 1 2 3 5 8 13 21) 5)
            â‡’ 8

 -- Procedure: bytevector-u8-set! bytevector k byte
     It is an error if K is not a valid index of BYTEVECTOR.  Stores
     BYTE as the Kth byte of BYTEVECTOR.
          (let ((bv (bytevector 1 2 3 4)
            (bytevector-u8-set! bv 1 3)
            bv)
            â‡’ #u8(1 3 3 4)

 -- Procedure: bytevector-copy bytevector [start [end]]
     Returns a newly allocated bytevector containing the bytes in
     BYTEVECTOR between START and END.

          (define a #u8(1 2 3 4 5))
          (bytevector-copy a 2 4))
              â‡’ #u8(3 4)

 -- Procedure: bytevector-copy! to at from [start [end]]
     Copies the bytes of bytevectorFROM between START and END to
     bytevector TO, starting at AT.  The order in which bytes are copied
     is unspecified, except that if the source and destination overlap,
     copying takes place as if the source is first copied into a
     temporary bytevector and then into the destination.  This is
     achieved without allocating storage by making sure to copy in the
     correct direction in such circumstances.

     It is an error if AT is less than zero or greater than the length
     of TO.  It is also an error if â€˜(- (bytevector-length TO) AT)â€™ is
     less than â€˜(- END START)â€™.

          (define a (bytevector 1 2 3 4 5))
          (define b (bytevector 10 20 30 40 50))
          (bytevector-copy! b 1 a 0 2)
          b        â‡’ #u8(10 1 2 40 50)

 -- Procedure: bytevector-append bytevector...
     Returns a newly allocated bytevector whose elements are the
     concatenation of the elements in the given bytevectors.

          (bytevector-append #u8(0 1 2) #u8(3 4 5))
                  â‡’  #u8(0 1 2 3 4 5)

 -- Procedure: utf8->string bytevector [start [end]]
     This procedure decodes the bytes of a bytevector between START and
     END, interpreting as a UTF-8-encoded string, and returns the
     corresponding string.  It is an error for BYTEVECTOR to contain
     invalid UTF-8 byte sequences.
          (utf8->string #u8(#x41))  â‡’ "A"

 -- Procedure: string->utf8 string [start [end]]
     This procedure encodes the characters of a string between START and
     END and returns the corresponding bytevector, in UTF-8 encoding.
          (string->utf8 "Î»")     â‡’ " #u8(#xCE #xBB)


File: kawa.info,  Node: Streams,  Next: Arrays,  Prev: Bytevectors,  Up: Data structures

13.6 Streams - lazy lists
=========================

Streams, sometimes called lazy lists, are a sequential data structure
containing elements computed only on demand.  A stream is either null or
is a pair with a stream in its cdr.  Since elements of a stream are
computed only when accessed, streams can be infinite.  Once computed,
the value of a stream element is cached in case it is needed again.

   _Note:_ These are not the same as Java 8 streams.

     (require 'srfi-41)
     (define fibs
       (stream-cons 1
         (stream-cons 1
           (stream-map +
             fibs
             (stream-cdr fibs)))))
     (stream->list 8 fibs) â‡’ (1 1 2 3 5 8 13 21)

   See the SRFI 41 specification
(http://srfi.schemers.org/srfi-41/srfi-41.html) for details.

   The Kawa implementations builds on *note promises: Lazy evaluation.
The â€˜stream-nullâ€™ value is a promise that evaluates to the empty list.
The result of â€˜stream-consâ€™ is an eager immutable pair whose â€˜carâ€™ and
â€˜cdrâ€™ properties return promises.


File: kawa.info,  Node: Arrays,  Next: Hash tables,  Prev: Streams,  Up: Data structures

13.7 Multi-dimensional Arrays
=============================

Arrays are heterogeneous data structures whose elements are indexed by
integer sequences of fixed length.  The length of a valid index sequence
is the rank or the number of dimensions of an array.  The shape of an
array consists of bounds for each index.

   The lower bound B and the upper bound E of a dimension are exact
integers with â€˜(<= B E)â€™.  A valid index along the dimension is an exact
integer K that satisfies both â€˜(<= B K)â€™ and â€˜(< K E)â€™.  The length of
the array along the dimension is the difference â€˜(- E B)â€™.  The size of
an array is the product of the lengths of its dimensions.

   A shape is specified as an even number of exact integers.  These are
alternately the lower and upper bounds for the dimensions of an array.

 -- Procedure: array? obj
     Returns â€˜#tâ€™ if OBJ is an array, otherwise returns â€˜#fâ€™.

 -- Procedure: shape bound ...
     Returns a shape.  The sequence BOUND ...  must consist of an even
     number of exact integers that are pairwise not decreasing.  Each
     pair gives the lower and upper bound of a dimension.  If the shape
     is used to specify the dimensions of an array and BOUND ...  is the
     sequence B0 E0 ...  BK EK ...  of N pairs of bounds, then a valid
     index to the array is any sequence J0 ...  JK ...  of N exact
     integers where each JK satisfies â€˜(<= BK JK)â€™ and â€˜(< JK EK)â€™.

     The shape of a D-dimensional array is a D * 2 array where the
     element at K 0 contains the lower bound for an index along
     dimension K and the element at K 1 contains the corresponding upper
     bound, where K satisfies â€˜(<= 0 K)â€™ and â€˜(< K D)â€™.

 -- Procedure: make-array shape
 -- Procedure: make-array shape obj
     Returns a newly allocated array whose shape is given by SHAPE.  If
     OBJ is provided, then each element is initialized to it.  Otherwise
     the initial contents of each element is unspecified.  The array
     does not retain a reference to SHAPE.

 -- Procedure: array shape obj ...
     Returns a new array whose shape is given by SHAPE and the initial
     contents of the elements are OBJ ...  in row major order.  The
     array does not retain a reference to SHAPE.

 -- Procedure: array-rank array
     Returns the number of dimensions of ARRAY.
          (array-rank
            (make-array (shape 1 2 3 4)))
     Returns 2.

 -- Procedure: array-start array k
     Returns the lower bound for the index along dimension K.

 -- Procedure: array-end array k
     Returns the upper bound for the index along dimension K.

 -- Procedure: array-ref array k ...
 -- Procedure: array-ref array index
     Returns the contents of the element of ARRAY at index K ....  The
     sequence K ...  must be a valid index to ARRAY.  In the second
     form, INDEX must be either a vector or a 0-based 1-dimensional
     array containing K ....
          (array-ref (array (shape 0 2 0 3)
                        'uno 'dos 'tres
                        'cuatro 'cinco 'seis)
             1 0)
     Returns â€˜cuatroâ€™.
          (let ((a (array (shape 4 7 1 2) 3 1 4)))
             (list (array-ref a 4 1)
                   (array-ref a (vector 5 1))
                   (array-ref a (array (shape 0 2)
                                   6 1))))
     Returns â€˜(3 1 4)â€™.

 -- Procedure: array-set! array k ... obj
 -- Procedure: array-set! array index obj
     Stores OBJ in the element of ARRAY at index K ....  Returns the
     void value.  The sequence K ...  must be a valid index to ARRAY.
     In the second form, INDEX must be either a vector or a 0-based
     1-dimensional array containing K ....

          (let ((a (make-array
                      (shape 4 5 4 5 4 5))))
             (array-set! a 4 4 4 "huuhkaja")
             (array-ref a 4 4 4))
     Returns â€˜"huuhkaja"â€™.

 -- Procedure: share-array array shape proc
     Returns a new array of SHAPE shape that shares elements of ARRAY
     through PROC.  The procedure PROC must implement an affine function
     that returns indices of ARRAY when given indices of the array
     returned by â€˜share-arrayâ€™.  The array does not retain a reference
     to SHAPE.
          (define i_4
             (let* ((i (make-array
                          (shape 0 4 0 4)
                          0))
                    (d (share-array i
                          (shape 0 4)
                          (lambda (k)
                             (values k k)))))
                (do ((k 0 (+ k 1)))
                    ((= k 4))
                   (array-set! d k 1))
                i))

     Note: the affinity requirement for PROC means that each value must
     be a sum of multiples of the arguments passed to PROC, plus a
     constant.

     Implementation note: arrays have to maintain an internal index
     mapping from indices K1 ...  KD to a single index into a backing
     vector; the composition of this mapping and PROC can be recognised
     as â€˜(+ N0 (* N1 K1) ... (* ND KD))â€™ by setting each index in turn
     to 1 and others to 0, and all to 0 for the constant term; the
     composition can then be compiled away, together with any complexity
     that the user introduced in their procedure.

   Multi-dimensional arrays are specified by SRFI-25
(http://srfi.schemers.org/srfi-25/srfi-25.html).  In Kawa, a
one-dimensional array whose lower bound is 0 is also a sequence.
Furthermore, if such an array is simple (not created â€˜share-arrayâ€™) it
will be implemented using a â€˜<vector>â€™.  Uniform vectors and strings are
also arrays in Kawa.  For example:
     (share-array
      (f64vector 1.0 2.0 3.0 4.0 5.0 6.0)
      (shape 0 2 0 3)
      (lambda (i j) (+ (* 2 i) j)))
   evaluates to a two-dimensionsal array of â€˜<double>â€™:
     #2a((1.0 2.0 3.0) (3.0 4.0 5.0))


File: kawa.info,  Node: Hash tables,  Prev: Arrays,  Up: Data structures

13.8 Hash tables
================

A "hashtable" is a data structure that associates keys with values.  The
hashtable has no intrinsic order for the (key, value) associations it
contains, and supports in-place modification as the primary means of
setting the contents of a hash table.  Any object can be used as a key,
provided a "hash function" and a suitable "equivalence function" is
available.  A hash function is a procedure that maps keys to exact
integer objects.

   The hashtable provides key lookup and destructive update in amortised
constant time, provided that a good hash function is used.  A hash
function H is acceptable for an equivalence predicate E iff â€˜(E OBJ1
OBJ2)â€™ implies â€˜(= (H OBJ1) (H OBJ2))â€™.  A hash function H is good for a
equivalence predicate E if it distributes the resulting hash values for
non-equal objects (by E) as uniformly as possible over the range of hash
values, especially in the case when some (non-equal) objects resemble
each other by e.g.  having common subsequences.  This definition is
vague but should be enough to assert that e.g.  a constant function is
not a good hash function.

   Kawa provides two complete sets of functions for hashtables:
   â€¢ The functions specified by R6RS have names starting with
     â€˜hashtable-â€™
   â€¢ The functions specified by the older SRFI-69
     (http://srfi.schemers.org/srfi-69/srfi-69.html) specifiation have
     names starting with â€˜hash-table-â€™

   Both interfaces use the same underlying datatype, so it is possible
to mix and match from both sets.  That datatype implements
â€˜java.util.Mapâ€™.  Freshly-written code should probably use the R6RS
functions.

13.8.1 R6RS hash tables
-----------------------

To use these hash table functions in your Kawa program you must first:

     (import (rnrs hashtables))

   This section uses the HASHTABLE parameter name for arguments that
must be hashtables, and the KEY parameter name for arguments that must
be hashtable keys.

 -- Procedure: make-eq-hashtable
 -- Procedure: make-eq-hashtable K
     Return a newly allocated mutable hashtable that accepts arbitrary
     objects as keys, and compares those keys with â€˜eq?â€™.  If an
     argument is given, the initial capacity of the hashtable is set to
     approximately K elements.

 -- Procedure: make-eqv-hashtable
 -- Procedure: make-eqv-hashtable K
     Return a newly allocated mutable hashtable that accepts arbitrary
     objects as keys, and compares those keys with â€˜eqv?â€™.  If an
     argument is given, the initial capacity of the hashtable is set to
     approximately K elements.

 -- Procedure: make-hashtable HASH-FUNCTION EQUIV
 -- Procedure: make-hashtable HASH-FUNCTION EQUIV K
     HASH-FUNCTION and EQUIV must be procedures.  HASH-FUNCTION should
     accept a key as an argument and should return a nonâ€“negative exact
     integer object.  EQUIV should accept two keys as arguments and
     return a single value.  Neither procedure should mutate the
     hashtable returned by â€˜make-hashtableâ€™.

     The â€˜make-hashtableâ€™ procedure returns a newly allocated mutable
     hashtable using HASH-FUNCTION as the hash function and EQUIV as the
     equivalence function used to compare keys.  If a third argument is
     given, the initial capacity of the hashtable is set to
     approximately K elements.

     Both HASH-FUNCTION and EQUIV should behave like pure functions on
     the domain of keys.  For example, the â€˜string-hashâ€™ and â€˜string=?â€™
     procedures are permissible only if all keys are strings and the
     contents of those strings are never changed so long as any of them
     continues to serve as a key in the hashtable.  Furthermore, any
     pair of keys for which EQUIV returns true should be hashed to the
     same exact integer objects by HASH-FUNCTION.

          _Note:_ Hashtables are allowed to cache the results of calling
          the hash function and equivalence function, so programs cannot
          rely on the hash function being called for every lookup or
          update.  Furthermore any hashtable operation may call the hash
          function more than once.

13.8.1.1 Procedures
...................

 -- Procedure: hashtable? OBJ
     Return â€˜#tâ€™ if OBJ is a hashtable, â€˜#fâ€™ otherwise.

 -- Procedure: hashtable-size HASHTABLE
     Return the number of keys contained in HASHTABLE as an exact
     integer object.

 -- Procedure: hashtable-ref HASHTABLE KEY DEFAULT
     Return the value in HASHTABLE associated with KEY.  If HASHTABLE
     does not contain an association for KEY, DEFAULT is returned.

 -- Procedure: hashtable-set! HASHTABLE KEY OBJ
     Change HASHTABLE to associate KEY with OBJ, adding a new
     association or replacing any existing association for KEY, and
     returns unspecified values.

 -- Procedure: hashtable-delete! HASHTABLE KEY
     Remove any association for KEY within HASHTABLE and returns
     unspecified values.

 -- Procedure: hashtable-contains? HASHTABLE KEY
     Return â€˜#tâ€™ if HASHTABLE contains an association for KEY, â€˜#fâ€™
     otherwise.

 -- Procedure: hashtable-update! HASHTABLE KEY PROC DEFAULT
     PROC should accept one argument, should return a single value, and
     should not mutate HASHTABLE.

     The â€˜hashtable-update!â€™ procedure applies PROC to the value in
     HASHTABLE associated with KEY, or to DEFAULT if HASHTABLE does not
     contain an association for KEY.  The HASHTABLE is then changed to
     associate KEY with the value returned by PROC.

     The behavior of â€˜hashtable-update!â€™ is equivalent to the following
     code, but is may be (and is in Kawa) implemented more efficiently
     in cases where the implementation can avoid multiple lookups of the
     same key:

          (hashtable-set!
            hashtable key
            (proc (hashtable-ref
                   hashtable key default)))

 -- Procedure: hashtable-copy HASHTABLE
 -- Procedure: hashtable-copy HASHTABLE MUTABLE
     Return a copy of HASHTABLE.  If the MUTABLE argument is provided
     and is true, the returned hashtable is mutable; otherwise it is
     immutable.

 -- Procedure: hashtable-clear! HASHTABLE
 -- Procedure: hashtable-clear! HASHTABLE K
     Remove all associations from HASHTABLE and returns unspecified
     values.

     If a second argument is given, the current capacity of the
     hashtable is reset to approximately K elements.

 -- Procedure: hashtable-keys HASHTABLE
     Return a vector of all keys in HASHTABLE.  The order of the vector
     is unspecified.

 -- Procedure: hashtable-entries HASHTABLE
     Return two values, a vector of the keys in HASHTABLE, and a vector
     of the corresponding values.

     Example:

          (let ((h (make-eqv-hashtable)))
            (hashtable-set! h 1 'one)
            (hashtable-set! h 2 'two)
            (hashtable-set! h 3 'three)
            (hashtable-entries h))
          â‡’ #(1 2 3) #(one two three) ; two return values

     the order of the entries in the result vectors is not known.

13.8.1.2 Inspection
...................

 -- Procedure: hashtable-equivalence-function HASHTABLE
     Return the equivalence function used by HASHTABLE to compare keys.
     For hashtables created with â€˜make-eq-hashtableâ€™ and
     â€˜make-eqv-hashtableâ€™, returns â€˜eq?â€™ and â€˜eqv?â€™ respectively.

 -- Procedure: hashtable-hash-function HASHTABLE
     Return the hash function used by HASHTABLE.  For hashtables created
     by â€˜make-eq-hashtableâ€™ or â€˜make-eqv-hashtableâ€™, â€˜#fâ€™ is returned.

 -- Procedure: hashtable-mutable? HASHTABLE
     Return â€˜#tâ€™ if HASHTABLE is mutable, otherwise â€˜#fâ€™.

13.8.1.3 Hash functions
.......................

The â€˜equal-hashâ€™, â€˜string-hashâ€™, and â€˜string-ci-hashâ€™ procedures of this
section are acceptable as the hash functions of a hashtable only if the
keys on which they are called are not mutated while they remain in use
as keys in the hashtable.

 -- Procedure: equal-hash OBJ
     Return an integer hash value for OBJ, based on its structure and
     current contents.  This hash function is suitable for use with
     â€˜equal?â€™ as an equivalence function.
          _Note:_ Like â€˜equal?â€™, the â€˜equal-hashâ€™ procedure must always
          terminate, even if its arguments contain cycles.

 -- Procedure: string-hash STRING
     Return an integer hash value for STRING, based on its current
     contents.  This hash function is suitable for use with â€˜string=?â€™
     as an equivalence function.

 -- Procedure: string-ci-hash STRING
     Return an integer hash value for STRING based on its current
     contents, ignoring case.  This hash function is suitable for use
     with â€˜string-ci=?â€™ as an equivalence function.

 -- Procedure: symbol-hash SYMBOL
     Return an integer hash value for SYMBOL.

13.8.2 SRFI-69 hash tables
--------------------------

To use these hash table functions in your Kawa program you must first:
     (require 'srfi-69)
   or
     (require 'hash-table)
   or
     (import (srfi 69 basic-hash-tables))

13.8.2.1 Type constructors and predicate
........................................

 -- Procedure: make-hash-table [ equal? [ hash [ size-hint]]] â†’
          hash-table

     Create a new hash table with no associations.  The EQUAL? parameter
     is a predicate that should accept two keys and return a boolean
     telling whether they denote the same key value; it defaults to the
     â€˜equal?â€™ function.

     The HASH parameter is a hash function, and defaults to an
     appropriate hash function for the given EQUAL? predicate (see the
     Hashing section).  However, an acceptable default is not guaranteed
     to be given for any equivalence predicate coarser than â€˜equal?â€™,
     except for â€˜string-ci=?â€™.  (The function â€˜hashâ€™ is acceptable for
     â€˜equal?â€™, so if you use coarser equivalence than â€˜equal?â€™ other
     than â€˜string-ci=?â€™, you must always provide the function hash
     yourself.)  (An equivalence predicate C1 is coarser than a
     equivalence predicate C2 iff there exist values X and Y such that
     â€˜(and (C1 X Y) (not (C2 X Y)))â€™.)

     The SIZE-HINT parameter can be used to suggested an approriate
     initial size.  This option is not part of the SRFI-69 specification
     (though it is handled by the reference implementation), so
     specifying that option might be unportable.

 -- Procedure: hash-table? obj â†’ boolean
     A predicate to test whether a given object OBJ is a hash table.

 -- Procedure: alist->hash-table alist [ equal? [ hash [ size-hint]]] â†’
          hash-table

     Takes an association list ALIST and creates a hash table HASH-TABLE
     which maps the â€˜carâ€™ of every element in ALIST to the â€˜cdrâ€™ of
     corresponding elements in ALIST.  The EQUAL?, HASH, and SIZE-HINT
     parameters are interpreted as in â€˜make-hash-tableâ€™.  If some key
     occurs multiple times in ALIST, the value in the first association
     will take precedence over later ones.  (Note: the choice of using
     â€˜cdrâ€™ (instead of â€˜cadrâ€™) for values tries to strike balance
     between the two approaches: using CADR would render this procedure
     unusable for â€˜cdrâ€™ alists, but not vice versa.)

13.8.2.2 Reflective queries
...........................

 -- Procedure: hash-table-equivalence-function hash-table
     Returns the equivalence predicate used for keys of HASH-TABLE.

 -- Procedure: hash-table-hash-function hash-table
     Returns the hash function used for keys of HASH-TABLE.

13.8.2.3 Dealing with single elements
.....................................

 -- Procedure: hash-table-ref hash-table key [ thunk ] â†’ value
     This procedure returns the value associated to KEY in HASH-TABLE.
     If no value is associated to KEY and THUNK is given, it is called
     with no arguments and its value is returned; if THUNK is not given,
     an error is signalled.  Given a good hash function, this operation
     should have an (amortised) complexity of O(1) with respect to the
     number of associations in HASH-TABLE.

 -- Procedure: hash-table-ref/default hash-table key default â†’ value
     Evaluates to the same value as â€˜(hash-table-ref HASH-TABLE KEY
     (lambda () DEFAULT))â€™.  Given a good hash function, this operation
     should have an (amortised) complexity of O(1) with respect to the
     number of associations in hash-table.

 -- Procedure: hash-table-set! hash-table key value â†’ void
     This procedure sets the value associated to KEY in HASH-TABLE.  The
     previous association (if any) is removed.  Given a good hash
     function, this operation should have an (amortised) complexity of
     O(1) with respect to the number of associations in hash-table.

 -- Procedure: hash-table-delete! hash-table key â†’ void
     This procedure removes any association to KEY in HASH-TABLE.  It is
     not an error if no association for the KEY exists; in this case,
     nothing is done.  Given a good hash function, this operation should
     have an (amortised) complexity of O(1) with respect to the number
     of associations in hash-table.

 -- Procedure: hash-table-exists? hash-table key â†’ boolean
     This predicate tells whether there is any association to KEY in
     HASH-TABLE.  Given a good hash function, this operation should have
     an (amortised) complexity of O(1) with respect to the number of
     associations in hash-table.

 -- Procedure: hash-table-update! hash-table key function [ thunk ] â†’
          void
     Semantically equivalent to, but may be implemented more efficiently
     than, the following code:
          (hash-table-set! HASH-TABLE KEY
                           (function (hash-table-ref HASH-TABLE KEY THUNK)))

 -- Procedure: hash-table-update!/default hash-table key function
          default â†’ void
     Behaves as if it evaluates to â€˜(hash-table-update! HASH-TABLE KEY
     FUNCTION (lambda () DEFAULT))â€™.

13.8.2.4 Dealing with the whole contents
........................................

 -- Procedure: hash-table-size hash-table â†’ integer
     Returns the number of associations in HASH-TABLE.  This operation
     takes constant time.

 -- Procedure: hash-table-keys hash-table â†’ list
     Returns a list of keys in HASH-TABLE.  The order of the keys is
     unspecified.

 -- Procedure: hash-table-values hash-table â†’ list
     Returns a list of values in HASH-TABLE.  The order of the values is
     unspecified, and is not guaranteed to match the order of keys in
     the result of â€˜hash-table-keysâ€™.

 -- Procedure: hash-table-walk hash-table proc â†’ void
     PROC should be a function taking two arguments, a key and a value.
     This procedure calls PROC for each association in HASH-TABLE,
     giving the key of the association as key and the value of the
     association as value.  The results of PROC are discarded.  The
     order in which PROC is called for the different associations is
     unspecified.

 -- Procedure: hash-table-fold hash-table f init-value â†’ final-value
     This procedure calls F for every association in HASH-TABLE with
     three arguments: the key of the association key, the value of the
     association value, and an accumulated value, VAL.  The VAL is
     INIT-VALUE for the first invocation of F, and for subsequent
     invocations of F, the return value of the previous invocation of F.
     The value FINAL-VALUE returned by â€˜hash-table-foldâ€™ is the return
     value of the last invocation of F.  The order in which F is called
     for different associations is unspecified.

 -- Procedure: hash-table->alist hash-table â†’ alist
     Returns an association list such that the â€˜carâ€™ of each element in
     ALIST is a key in HASH-TABLE and the corresponding â€˜cdrâ€™ of each
     element in ALIST is the value associated to the key in HASH-TABLE.
     The order of the elements is unspecified.

     The following should always produce a hash table with the same
     mappings as a hash table H:
          (alist->hash-table (hash-table->alist H)
                                  (hash-table-equivalence-function H)
                                  (hash-table-hash-function H))

 -- Procedure: hash-table-copy hash-table â†’ hash-table
     Returns a new hash table with the same equivalence predicate, hash
     function and mappings as in HASH-TABLE.

 -- Procedure: hash-table-merge! hash-table1 hash-table2 â†’ hash-table
     Adds all mappings in HASH-TABLE2 into HASH-TABLE1 and returns the
     resulting hash table.  This function may modify HASH-TABLE1
     destructively.

13.8.2.5 Hash functions
.......................

The Kawa implementation always calls these hash functions with a single
parameter, and expects the result to be within the entire (32-bit
signed) â€˜intâ€™ range, for compatibility with standard â€˜hashCodeâ€™ methods.

 -- Procedure: hash object [ bound ] â†’ integer
     Produces a hash value for object in the range from 0 (inclusive) tp
     to BOUND (exclusive).

     If BOUND is not given, the Kawa implementation returns a value
     within the range â€˜(- (expt 2 32))â€™ (inclusive) to â€˜(- (expt 2 32) 1)â€™
     (inclusive).  It does this by calling the standard â€˜hashCodeâ€™
     method, and returning the result as is.  (If the OBJECT is the Java
     â€˜nullâ€™ value, 0 is returned.)  This hash function is acceptable for
     â€˜equal?â€™.

 -- Procedure: string-hash string [ bound ] â†’ integer
     The same as â€˜hashâ€™, except that the argument string must be a
     string.  (The Kawa implementation returns the same as the â€˜hashâ€™
     function.)

 -- Procedure: string-ci-hash string [ bound ] â†’ integer
     The same as â€˜string-hashâ€™, except that the case of characters in
     string does not affect the hash value produced.  (The Kawa
     implementation returns the same the â€˜hashâ€™ function applied to the
     lower-cased STRING.)

 -- Procedure: hash-by-identity object [ bound ] â†’ integer
     The same as â€˜hashâ€™, except that this function is only guaranteed to
     be acceptable for â€˜eq?â€™.  Kawa uses the â€˜identityHashCodeâ€™ method
     of â€˜java.lang.Systemâ€™.


File: kawa.info,  Node: Eval and Environments,  Next: Debugging,  Prev: Data structures,  Up: Top

14 Eval and Environments
************************

 -- Procedure: environment list^*
     This procedure returns a specifier for the environment that results
     by starting with an empty environment and then importing each LIST,
     considered as an IMPORT-SET, into it.  The bindings of the
     environment represented by the specifier are immutable, as is the
     environment itself.  See the â€˜evalâ€™ function for examples.

 -- Procedure: null-environment version
     This procedure returns an environment that contains no variable
     bindings, but contains (syntactic) bindings for all the syntactic
     keywords.

     The effect of assigning to a variable in this environment (such as
     â€˜letâ€™) is undefined.

 -- Procedure: scheme-report-environment version
     The VERSION must be an exact non-negative inetger corresponding to
     a version of one of the RevisedVERSION Reports on Scheme.  The
     procedure returns an environment that contains exactly the set of
     bindings specified in the corresponding report.

     This implementation supports VERSION that is 4 or 5.

     The effect of assigning to a variable in this environment (such as
     â€˜carâ€™) is undefined.

 -- Procedure: interaction-environment
     This procedure return an environment that contains
     implementation-defined bindings, as well as top-level user
     bindings.

 -- Procedure: environment-bound? environment symbol
     Return true â€˜#tâ€™ if there is a binding for SYMBOL in ENVIRONMENT;
     otherwise returns â€˜#fâ€™.

 -- Syntax: fluid-let ((variable init) ...) body ...
     Evaluate the INIT expressions.  Then modify the dynamic bindings
     for the VARIABLES to the values of the INIT expressions, and
     evaluate the BODY expressions.  Return the result of the last
     expression in BODY.  Before returning, restore the original
     bindings.  The temporary bindings are only visible in the current
     thread, and its descendent threads.

 -- Procedure: base-uri [node]
     If NODE is specified, returns the base-URI property of the NODE.
     If the NODE does not have the base-URI property, returns â€˜#fâ€™.
     (The XQuery version returns the empty sequence in that case.)

     In the zero-argument case, returns the "base URI" of the current
     context.  By default the base URI is the current working directory
     (as a URL). While a source file is â€˜loadâ€™ed, the base URI is
     temporarily set to the URL of the document.

 -- Procedure: eval expression [environment]
     This procedure evaluates EXPRESSION in the environment indicated by
     ENVIRONMENT.  The default for ENVIRONMENT is the result of
     â€˜(interaction-environment)â€™.

          (eval â€™(* 7 3) (environment '(scheme base)))
                      â‡’ 21

          (let ((f (eval '(lambda (f x) (f x x))
                         (null-environment 5))))
            (f + 10))
                      â‡’ 20

          (eval '(define foo 32) (environment '(scheme base)))
                      â‡’ error is signaled

 -- Procedure: load path [environment]
 -- Procedure: load-relative path [environment]
     The PATH can be an (absolute) URL or a filename of a source file,
     which is read and evaluated line-by-line.  The PATH can also be a
     fully-qualified class name.  (Mostly acts like the â€˜-fâ€™
     command-line option, but with different error handling.)  Since
     â€˜loadâ€™ is a run-time function it doesnâ€™t know about the enclosing
     lexical environment, and the latter canâ€™t know about definitions
     introduced by â€˜loadâ€™.  For those reasons it is highly recommended
     that you use instead use â€˜*note require: require.â€™ or â€˜*note
     include: include.â€™.

     Evaluation is done in the specified ENVIRONMENT, which defauls to
     result of â€˜(interaction-environment)â€™.

     The â€˜load-relativeâ€™ procedure is like â€˜loadâ€™, except that PATH is a
     URI that is relative to the contextâ€™s current base URI.

* Menu:

* Locations::
* Parameter objects::


File: kawa.info,  Node: Locations,  Next: Parameter objects,  Up: Eval and Environments

14.1 Locations
==============

A "location" is a place where a value can be stored.  An "lvalue" is an
expression that refers to a location.  (The name "lvalue" refers to the
fact that the left operand of â€˜set!â€™ is an lvalue.)  The only kind of
lvalue in standard Scheme is a "variable".  Kawa also allows "computed
lvalues".  These are procedure calls used in "lvalue context", such as
the left operand of â€˜set!â€™.

   You can only use procedures that have an associated "setter".  In
that case, â€˜(set! (f arg ...) value)â€™ is equivalent to â€˜((setter f) arg
... value)â€™ Currently, only a few procedures have associated â€˜setterâ€™s,
and only builtin procedures written in Java can have â€˜setterâ€™s.

   For example:
     (set! (car x) 10)
   is equivalent to:
     ((setter car) x 10)
   which is equivalent to:
     (set-car! x 10)

 -- Procedure: setter procedure
     Gets the "setter procedure" associated with a "getter procedure".
     Equivalent to â€˜(procedure-property PROCEDURE 'setter)â€™.  By
     convention, a setter procedure takes the same parameters as the
     "getter" procedure, plus an extra parameter that is the new value
     to be stored in the location specified by the parameters.  The
     expectation is that following â€˜((setter PROC) ARGS ... VALUE)â€™ then
     the value of â€˜(PROC ARGS ...)â€™ will be VALUE.

     The â€˜setterâ€™ of â€˜setterâ€™ can be used to set the â€˜setterâ€™ property.
     For example the Scheme prologue effectively does the following:
          (set! (setter vector-set) vector-set!)

   Kawa also gives you access to locations as first-class values:

 -- Syntax: location lvalue
     Returns a location object for the given LVALUE.  You can get its
     value (by applying it, as if it were a procedure), and you can set
     its value (by using â€˜set!â€™ on the application).  The LVALUE can be
     a local or global variable, or a procedure call using a procedure
     that has a â€˜setterâ€™.
          (define x 100)
          (define lx (location x))
          (set! (lx) (cons 1 2)) ;; set x to (1 . 2)
          (lx)  ;; returns (1 . 2)
          (define lc (location (car x)))
          (set! (lc) (+ 10 (lc)))
          ;; x is now (11 . 2)

 -- Syntax: define-alias variable lvalue
     Define VARIABLE as an alias for LVALUE.  In other words, makes it
     so that â€˜(location VARIABLE)â€™ is equivalent to â€˜(location LVALUE)â€™.
     This works both top-level and inside a function.

 -- Syntax: define-private-alias variable lvalue
     Same as â€˜define-aliasâ€™, but the VARIABLE is local to the current
     module.

   Some people might find it helpful to think of a location as a
settable "thunk".  Others may find it useful to think of the â€˜locationâ€™
syntax as similar to the C â€˜&â€™ operator; for the â€˜*â€™ indirection
operator, Kawa uses procedure application.

   You can use â€˜define-aliasâ€™ to define a shorter type synonym, similar
to Javaâ€™s â€˜import TypeNameâ€™ (single-type-import) declaration:
     (define-alias StrBuf java.lang.StringBuffer)


File: kawa.info,  Node: Parameter objects,  Prev: Locations,  Up: Eval and Environments

14.2 Parameter objects
======================

A parameter object is a procedure that is bound to a location, and may
optionally have a conversion procedure.  The procedure accepts zero or
one argument.  When the procedure is called with zero arguments, the
content of the location is returned.  On a call with one argument the
content of the location is updated with the result of applying the
parameter objectâ€™s conversion procedure to the argument.

   Parameter objects are created with the â€˜make-parameterâ€™ procedure
which takes one or two arguments.  The second argument is a one argument
conversion procedure.  If only one argument is passed to make-parameter
the identity function is used as a conversion procedure.  A new location
is created and asociated with the parameter object.  The initial content
of the location is the result of applying the conversion procedure to
the first argument of make-parameter.

   Note that the conversion procedure can be used for guaranteeing the
type of the parameter objectâ€™s binding and/or to perform some conversion
of the value.

   The â€˜parameterizeâ€™ special form, when given a parameter object and a
value, binds the parameter object to a new location for the dynamic
extent of its body.  The initial content of the location is the result
of applying the parameter objectâ€™s conversion procedure to the value.
The â€˜parameterizeâ€™ special form behaves analogously to â€˜letâ€™ when
binding more than one parameter object (that is the order of evaluation
is unspecified and the new bindings are only visible in the body of the
parameterize special form).

   When a new thread is created using â€˜futureâ€™ or â€˜runnableâ€™ then the
child thread inherits initial values from its parent.  Once the child is
running, changing the value in the child does not affect the value in
the parent or vice versa.  (In the past this was not the case: The child
would share a location with the parent except within a â€˜parameterizeâ€™.
This was changed to avoid unsafe and inefficient coupling between
threads.)

   Note that â€˜parameterizeâ€™ and â€˜fluid-letâ€™ have similar binding and
sharing behavior.  The difference is that â€˜fluid-letâ€™ modifies locations
accessed by name, while â€˜make-parameterâ€™ and â€˜parameterizeâ€™ create
anonymous locations accessed by calling a parameter procedure.

   The R5RS procedures â€˜current-input-portâ€™ and â€˜current-output-portâ€™
are parameter objects.

 -- Procedure: make-parameter init [converter]

     Returns a new parameter object which is bound in the global dynamic
     environment to a location containing the value returned by the call
     â€˜(CONVERTER INIT)â€™.  If the conversion procedure converter is not
     specified the identity function is used instead.

     The parameter object is a procedure which accepts zero or one
     argument.  When it is called with no argument, the content of the
     location bound to this parameter object in the current dynamic
     environment is returned.  When it is called with one argument, the
     content of the location is set to the result of the call
     â€˜(CONVERTER ARG)â€™, where ARG is the argument passed to the
     parameter object, and an unspecified value is returned.

          (define radix
            (make-parameter 10))

          (define write-shared
            (make-parameter
              #f
              (lambda (x)
                (if (boolean? x)
                    x
                    (error "only booleans are accepted by write-shared")))))

          (radix)           â‡’  10
          (radix 2)
          (radix)           â‡’  2
          (write-shared 0)  gives an error

          (define prompt
            (make-parameter
              123
              (lambda (x)
                (if (string? x)
                    x
                    (with-output-to-string (lambda () (write x)))))))

          (prompt)       â‡’  "123"
          (prompt ">")
          (prompt)       â‡’  ">"

 -- Syntax: parameterize ((expr1 expr2) ...) BODY
     The expressions EXPR1 and EXPR2 are evaluated in an unspecified
     order.  The value of the EXPR1 expressions must be parameter
     objects.  For each EXPR1 expression and in an unspecified order,
     the local dynamic environment is extended with a binding of the
     parameter object EXPR1 to a new location whose content is the
     result of the call â€˜(CONVERTER VAL)â€™, where VAL is the value of
     EXPR2 and CONVERTER is the conversion procedure of the parameter
     object.  The resulting dynamic environment is then used for the
     evaluation of BODY (which refers to the R5RS grammar nonterminal of
     that name).  The result(s) of the parameterize form are the
     result(s) of the BODY.

          (radix)                                              â‡’  2
          (parameterize ((radix 16)) (radix))                  â‡’  16
          (radix)                                              â‡’  2

          (define (f n) (number->string n (radix)))

          (f 10)                                               â‡’  "1010"
          (parameterize ((radix 8)) (f 10))                    â‡’  "12"
          (parameterize ((radix 8) (prompt (f 10))) (prompt))  â‡’  "1010"


File: kawa.info,  Node: Debugging,  Next: Input-Output,  Prev: Eval and Environments,  Up: Top

15 Debugging
************

 -- Syntax: trace procedure
     Cause PROCEDURE to be "traced", that is debugging output will be
     written to the standard error port every time PROCEDURE is called,
     with the parameters and return value.

     Note that Kawa will normally assume that a procedure defined with
     the procedure-defining variant of â€˜defineâ€™ is constant, and so it
     might be inlined:
          (define (ff x) (list x x))
          (trace ff) ;; probably won't work
          (ff 3)     ;; not traced
     It works if you specify the â€˜--no-inlineâ€™ flag to Kawa.
     Alternatively, you can use the variable-defining variant of
     â€˜defineâ€™:
          #|kawa:1|# (define ff (lambda (x) name: 'ff (list x x)))
          #|kawa:2|# (trace ff) ;; works
          #|kawa:3|# (ff 3)
          call to ff (3)
          return from ff => (3 3)
          (3 3)
     Note the use of the â€˜name:â€™ procedure property to give the
     anonymous â€˜lambdaâ€™ a name.

 -- Syntax: untrace procedure
     Turn off tracing (debugging output) of PROCEDURE.

 -- Procedure: disassemble procedure
     Returns a string representation of the disassembled bytecode for
     PROCEDURE, when known.


File: kawa.info,  Node: Input-Output,  Next: Types,  Prev: Debugging,  Up: Top

16 Input, output, and file handling
***********************************

Kawa has a number of useful tools for controlling input and output:

   A programmable reader.

   A powerful pretty-printer.

* Menu:

* Named output formats::
* Paths:: Paths - file name, URLs, and URIs
* Files:: File System Interface
* Reading and writing whole files::
* Ports::
* Format:: Formatted Output (Common-Lisp-style)
* Resources::


File: kawa.info,  Node: Named output formats,  Next: Paths,  Up: Input-Output

16.1 Named output formats
=========================

The â€˜--output-formatâ€™ (or â€˜--formatâ€™) command-line switch can be used to
override the default format for how values are printed on the standard
output.  This format is used for values printed by the read-eval-print
interactive interface.  It is also used to control how values are
printed when Kawa evaluates a file named on the command line (using the
â€˜-fâ€™ flag or a just a script name).  (It also effects applications
compiled with the â€˜--mainâ€™ flag.)  It currently effects how values are
printed by a â€˜loadâ€™, though that may change.

   The default format depends on the current programming language.  For
Scheme, the default is â€˜schemeâ€™ for read-eval-print interaction, and
â€˜ignoreâ€™ for files that are loaded.

   The formats currently supported include the following:
â€˜schemeâ€™
     Values are printed in a format matching the Scheme programming
     language, as if using â€˜displayâ€™.  "Groups" or "elements" are
     written as lists.
â€˜readable-schemeâ€™
     Like â€˜schemeâ€™, as if using â€˜writeâ€™: Values are generally printed in
     a way that they can be read back by a Scheme reader.  For example,
     strings have quotation marks, and character values are written like
     â€˜#\Aâ€™.
â€˜elispâ€™
     Values are printed in a format matching the Emacs Lisp programming
     language.  Mostly the same as â€˜schemeâ€™.
â€˜readable-elispâ€™
     Like â€˜elispâ€™, but values are generally printed in a way that they
     can be read back by an Emacs Lisp reader.  For example, strings
     have quotation marks, and character values are written like â€˜?Aâ€™.
â€˜clispâ€™
â€˜commonlispâ€™
     Values are printed in a format matching the Common Lisp programming
     language, as if written by â€˜princâ€™.  Mostly the same as â€˜schemeâ€™.
â€˜readable-clispâ€™
â€˜readable-commonlispâ€™
     Like â€˜clispâ€™, but as if written by â€˜prin1â€™: values are generally
     printed in a way that they can be read back by a Common Lisp
     reader.  For example, strings have quotation marks, and character
     values are written like â€˜#\Aâ€™.
â€˜xmlâ€™
â€˜xhtmlâ€™
â€˜htmlâ€™
     Values are printed in XML, XHTML, or HTML format.  This is
     discussed in more detail in *note Formatting XML::.
â€˜cgiâ€™
     The output should be a follow the CGI standards.  I.e.  assume that
     this script is invoked by a web server as a CGI script/program, and
     that the output should start with some response header, followed by
     the actual response data.  To generate the response headers, use
     the â€˜response-headerâ€™ function.  If the â€˜Content-typeâ€™ response
     header has not been specified, and it is required by the CGI
     standard, Kawa will attempt to infer an appropriate â€˜Content-typeâ€™
     depending on the following value.
â€˜ignoreâ€™
     Top-level values are ignored, instead of printed.


File: kawa.info,  Node: Paths,  Next: Files,  Prev: Named output formats,  Up: Input-Output

16.2 Paths - file name, URLs, and URIs
======================================

A "Path" is the name of a file or some other "resource".  The path
mechanism provides a layer of abstraction, so you can use the same
functions on either a filename or a URL/URI. Functions that in standard
Scheme take a filename have been generalized to take a path or a path
string, as if using the â€˜pathâ€™ function below.  For example:
     (open-input-file "http://www.gnu.org/index.html")
     (open-input-file (URI "ftp://ftp.gnu.org/README"))

 -- Type: path
     A general path, which can be a â€˜filenameâ€™ or a â€˜URIâ€™.  It can be
     either a â€˜filenameâ€™ or a â€˜URIâ€™.  Represented using the abstract
     Java class â€˜gnu.kawa.io.Pathâ€™.

     Coercing a value to a â€˜Pathâ€™ is equivalent to calling the â€˜pathâ€™
     constructor documented below.

 -- Constructor: path arg
     Coerces the ARG to a â€˜pathâ€™.  If ARG is already a â€˜pathâ€™, it is
     returned unchanged.  If ARG is a â€˜java.net.URIâ€™, or a
     â€˜java.net.URLâ€™ then a â€˜URIâ€™ value is returned.  If ARG is a
     â€˜java.io.Fileâ€™, a â€˜filepathâ€™ value is returned.  Otherwise, ARG can
     be a string.  A â€˜URIâ€™ value is returned if the string starts with a
     URI scheme (such as â€˜"http:"â€™), and a â€˜filepathâ€™ value is returned
     otherwise.

 -- Predicate: path? arg
     True if ARG is a â€˜pathâ€™ - i.e.  an instance of a
     â€˜gnu.kawa.io.Pathâ€™.

 -- Procedure: current-path [new-value]
     With no arguments, returns the default directory of the current
     thread as a â€˜pathâ€™.  This is used as the base directory for
     relative pathnames.  The initial value is that of the â€˜user.dirâ€™
     property as returned by â€˜(java.lang.System:getProperty
     "user.dir")â€™.

     If a NEW-VALUE argument is given, sets the default directory:
          (current-path "/opt/myApp/")
     A string value is automatically converted to a â€˜pathâ€™, normally a
     â€˜filepathâ€™.

     Alternatively, you can change the default using a setter:
          (set! (current-path) "/opt/myApp/")

     Since â€˜current-pathâ€™ is a *note parameter object: Parameter
     objects, you can locally change the value using *note
     â€˜parameterizeâ€™: parameterize-syntax.

 -- Type: filepath
     The name of a local file.  Represented using the Java class
     â€˜gnu.kawa.io.FilePathâ€™, which is a wrapper around â€˜java.io.Fileâ€™.

 -- Predicate: filepath? arg
     True if ARG is a â€˜filepathâ€™ - i.e.  an instance of a
     â€˜gnu.kawa.io.FilePathâ€™.

 -- Type: URI
     A Uniform Resource Indicator, which is a generalization of the more
     familiar URL. The general format is specified by RFC 2396: Uniform
     Resource Identifiers (URI): Generic Syntax
     (http://www.ietf.org/rfc/rfc2396.txt).  Represented using the Java
     class â€˜gnu.kawa.io.URIPathâ€™, which is a wrapper around
     â€˜java.net.URIâ€™.  A URI can be a URL, or it be a relative URI.

 -- Predicate: URI? arg
     True if ARG is a â€˜URIâ€™ - i.e.  an instance of a
     â€˜gnu.kawa.io.URIPathâ€™.

 -- Type: URL
     A Uniform Resource Locator - a subtype of â€˜URIâ€™.  Represented using
     the Java class â€˜gnu.kawa.io.URLPathâ€™, which is a wrapper around a
     â€˜java.net.URLâ€™, in addition to extending â€˜gnu.kawa.io.URIPathâ€™.

16.2.1 Extracting Path components
---------------------------------

 -- Procedure: path-scheme arg
     Returns the â€œURI schemeâ€ of ARG (coerced to a â€˜pathâ€™) if it is
     defined, or â€˜#fâ€™ otherwise.  The URI scheme of a â€˜filepathâ€™ is
     â€˜"file"â€™ if the â€˜filepathâ€™ is absolute, and â€˜#fâ€™ otherwise.
          (path-scheme "http://gnu.org/") â‡’ "http"

 -- Procedure: path-authority arg
     Returns the authority part of ARG (coerced to a â€˜pathâ€™) if it is
     defined, or â€˜#fâ€™ otherwise.  The â€œauthorityâ€ is usually the
     hostname, but may also include user-info or a port-number.

          (path-authority "http://me@localhost:8000/home") â‡’ "me@localhost:8000"

 -- Procedure: path-host arg
     Returns the name name part of ARG (coerced to a â€˜pathâ€™) if it is
     defined, or â€˜#fâ€™ otherwise.

          (path-host "http://me@localhost:8000/home") â‡’ "localhost"

 -- Procedure: path-user-info arg
     Returns the â€œuser infoâ€ of ARG (coerced to a â€˜pathâ€™) if it is
     specified, or â€˜#fâ€™ otherwise.

          (path-host "http://me@localhost:8000/home") â‡’ "me"

 -- Procedure: path-port arg
     Returns the port number of ARG (coerced to a â€˜pathâ€™) if it is
     specified, or â€˜-1â€™ otherwise.  Even if there is a default port
     associated with a URI scheme (such as 80 for â€˜httpâ€™), the value -1
     is returned unless the port number is _explictly_ specified.

          (path-host "http://me@localhost:8000/home") â‡’ 8000
          (path-host "http://me@localhost/home") â‡’ -1

 -- Procedure: path-file arg
     Returns the â€œpath componentâ€ of the ARG (coerced to a â€˜pathâ€™).
     (The name â€˜path-pathâ€™ might be more logical, but it is obviously a
     bit awkward.)  The path component of a file name is the file name
     itself.  For a URI, it is the main hierarchical part of the URI,
     without schema, authority, query, or fragment.
          (path-file "http://gnu.org/home/me.html?add-bug#body") â‡’ "/home/me.html"

 -- Procedure: path-directory arg
     If ARG (coerced to a â€˜pathâ€™) is directory, return ARG; otherwise
     return the â€œparentâ€ path, without the final component.
          (path-directory "http://gnu.org/home/me/index.html#body")
            â‡’ (path "http://gnu.org/home/me/")
          (path-directory "http://gnu.org/home/me/")
            â‡’ (path "http://gnu.org/home/me/")
     â€˜(path-directory "./dir")â€™ â€˜â‡’â€™ â€˜(path "./dir")â€™ if â€˜dirâ€™ is a
     directory, and â€˜(path ".")â€™ otherwise.

 -- Procedure: path-parent arg
     Returns the â€œparent directoryâ€ of ARG (coerced to a â€˜pathâ€™).  If
     ARG is not a directory, same as â€˜path-directory ARGâ€™.
          (path-parent "a/b/c") â‡’ (path "a/b")
          (path-parent "file:/a/b/c") â‡’ (path "file:/a/b/c")
          (path-parent "file:/a/b/c/") â‡’ (path "file:/a/b/")

 -- Procedure: path-last arg
     The last component of path component of ARG (coerced to a â€˜pathâ€™).
     Returns a substring of â€˜(path-file ARG)â€™.  If that string ends with
     â€˜/â€™ or the path separator, that last character is ignored.  Returns
     the tail of the path-string, following the last (non-final) â€˜/â€™ or
     path separator.
          (path-last "http:/a/b/c") â‡’ "c"
          (path-last "http:/a/b/c/") â‡’ "c"
          (path-last "a/b/c") â‡’ "c"

 -- Procedure: path-extension arg
     Returns the â€œextensionâ€ of the ARG (coerced to a â€˜pathâ€™).
          (path-extension "http://gnu.org/home/me.html?add-bug#body") â‡’ "html"
          (path-extension "/home/.init") â‡’ #f

 -- Procedure: path-query arg
     Returns the query part of ARG (coerced to a â€˜pathâ€™) if it is
     defined, or â€˜#fâ€™ otherwise.  The query part of a URI is the part
     after â€˜?â€™.
          (path-query "http://gnu.org/home?add-bug") â‡’ "add-bug"

 -- Procedure: path-fragment arg
     Returns the fragment part of ARG (coerced to a â€˜pathâ€™) if it is
     defined, or â€˜#fâ€™ otherwise.  The fragment of a URI is the part of
     after â€˜#â€™.
          (path-query "http://gnu.org/home#top") â‡’ "top"

 -- Procedure: resolve-uri uri base
     Returns a URI unchanged if it is an absolute URI. Otherwise
     resolves it against a base URI BASE, which is normally (though not
     always) absolute.

     This uses the algorithm specifyed by RFC-3986 (assuming BASE is
     absolute), unlike the obsolete RFC-2396 algorithm used by
     â€˜java.net.URI.resolveâ€™.


File: kawa.info,  Node: Files,  Next: Reading and writing whole files,  Prev: Paths,  Up: Input-Output

16.3 File System Interface
==========================

 -- Procedure: file-exists? filename
     Returns true iff the file named FILENAME actually exists.  This
     function is defined on arbitrary â€˜pathâ€™ values: for URI values we
     open a â€˜URLConnectionâ€™ and invoke â€˜getLastModified()â€™.

 -- Procedure: file-directory? filename
     Returns true iff the file named FILENAME actually exists and is a
     directory.  This function is defined on arbitrary â€˜pathâ€™ values;
     the default implementation for non-file objects is to return â€˜#tâ€™
     iff the path string ends with the character â€˜/â€™.

 -- Procedure: file-readable? filename
     Returns true iff the file named FILENAME actually exists and can be
     read from.

 -- Procedure: file-writable? filename
     Returns true iff the file named FILENAME actually exists and can be
     writen to.  (Undefined if the FILENAME does not exist, but the file
     can be created in the directory.)

 -- Procedure: delete-file filename
     Delete the file named FILENAME.  On failure, throws an exception.

 -- Procedure: rename-file oldname newname
     Renames the file named OLDNAME to NEWNAME.

 -- Procedure: copy-file oldname newname-from path-to
     Copy the file named OLDNAME to NEWNAME.  The return value is
     unspecified.

 -- Procedure: create-directory dirname
     Create a new directory named DIRNAME.  Unspecified what happens on
     error (such as exiting file with the same name).  (Currently
     returns â€˜#fâ€™ on error, but may change to be more compatible with
     scsh.)

 -- Procedure: system-tmpdir
     Return the name of the default directory for temporary files.

 -- Procedure: make-temporary-file [format]
     Return a file with a name that does not match any existing file.
     Use FORMAT (which defaults to â€˜"kawa~d.tmp"â€™) to generate a unique
     filename in â€˜(system-tmpdir)â€™.  The current implementation is _not_
     safe from race conditions; this will be fixed in a future release
     (using Java2 features).


File: kawa.info,  Node: Reading and writing whole files,  Next: Ports,  Prev: Files,  Up: Input-Output

16.4 Reading and writing whole files
====================================

The following procedures and syntax allow you to read and write the
entire contents of a file, without iterating using a port.

16.4.1 Reading a file
---------------------

For reading the contents of a file in a single operation, you can use
the following syntax:

     â€˜&<{â€™NAMED-LITERAL-PART+â€˜}â€™

   This is equivalent to using the â€˜path-dataâ€™ function (defined below):
     â€˜(path-dataâ€™ â€˜&{â€™NAMED-LITERAL-PART+â€˜})â€™

   For example:
     (define dir "/home/me/")
     (define help-message &<{&[dir]HELP})
   This binds â€˜help-messageâ€™ to the contents of the file named â€˜HELPâ€™ in
the â€˜dirâ€™ directory.

16.4.2 Blobs
------------

The contents of a file is in general a sequence of uninterpreted bytes.
Often these bytes represent text in a locale-dependent encoding, but we
donâ€™t always know this.  Sometimes theyâ€™re images, or videos, or
word-processor documents.  A filename extension or a â€œmagic numberâ€ in
the file can give you hints, but not certainty as to the type of the
data.

   A "blob (http://en.wikipedia.org/wiki/Binary_large_object)" is a raw
uninterpreted sequence of bytes.  It is a â€˜bytevectorâ€™ that can be
automatically converted to other types as needed, specifically to a
string or a bytevector.

   The â€˜&<{..}â€™ returns a blob.  For example, assume the file â€˜READMEâ€™
contains (bytes representing) the text â€˜"Check doc directory.\n"â€™.
Then:
     #|kawa:1|# (define readme &<{README}))
     |kawa:2|# readme:class
     class gnu.lists.Blob
     #|kawa:3|# (write (->string readme))
     "Check doc directory.\n"
     #|kawa:4|# (write (->bytevector readme))
     #u8(67 104 101 99 107 32 100 111 99 32 100 105 114 101 99 116 111 114 121 46 10)
     #|kawa:5|# (->bytevector readme):class
     class gnu.lists.U8Vector

16.4.3 Writing to a file
------------------------

The â€˜&<{..}â€™ syntax can be used with â€˜set!â€™ to replace the contents of a
file:
     (set! &<{README} "Check example.com\n")

   The new contents must be blob-compatible - i.e.  a bytevector or a
string.

   If you dislike using â€˜<â€™ as an output operator, you can instead using
the â€˜&>{..}â€™ operation, which evaluates to function whose single
argument is the new value:
     (&>{README} "Check example.com\n")
   In general:
     &>{NAMED-LITERAL-PART+}
   is equivalent to:
     (lambda (new-contents)
       (set! &<{NAMED-LITERAL-PART+} new-contents))

   You can use â€˜&>>â€™ to append more data to a file:

     (&>>{README} "or check example2.com\n")

16.4.4 Functions
----------------

 -- Procedure: path-data path
     Reads the contents of the file specified by PATH, where PATH can be
     a *note path: Paths. object, or anything that can be converted to a
     â€˜Pathâ€™, including a filename string or a URL. returning the result
     as a blob.  The result is a _blob_, which is a kind of bytevector
     than can be auto-converted to a string or bytevecor as required.

     The function â€˜path-dataâ€™ has a setter, which replaces the contents
     with new contents:
          (set! &<{file-name} new-contents)

 -- Procedure: path-bytes path
     Reads the contents of the file specified by PATH, as with the
     â€˜path-dataâ€™ function, but the result is a plain bytevector, rather
     than a blob.  This functtion also has a setter, which you can use
     to replace the file-contents by new bytevector-valued data.


File: kawa.info,  Node: Ports,  Next: Format,  Prev: Reading and writing whole files,  Up: Input-Output

16.5 Ports
==========

Ports represent input and output devices.  An input port is a Scheme
object that can deliver data upon command, while an output port is a
Scheme object that can accept data.

   Different "port types" operate on different data:
   â€¢ A "textual port" supports reading or writing of individual
     characters from or to a backing store containing characters using
     â€˜read-charâ€™ and â€˜write-charâ€™ below, and it supports operations
     defined in terms of characters, such as â€˜readâ€™ and â€˜writeâ€™.
   â€¢ A "binary port" supports reading or writing of individual bytes
     from or to a backing store containing bytes using â€˜read-u8â€™ and
     â€˜write-u8â€™ below, as well as operations defined in terms of bytes
     (integers in the range 0 to 255).

     All Kawa binary ports created by procedures documented here are
     also textual ports.  Thus you can either read/write bytes as
     described above, or read/write characters whose scalar value is in
     the range 0 to 255 (i.e.  the Latin-1 character set), using
     â€˜read-charâ€™ and â€˜write-charâ€™.

     A native binary port is a â€˜java.io.InputStreamâ€™ or
     â€˜java.io.OutputStreamâ€™ instance.  These are not textual ports.  You
     can use methods â€˜read-u8â€™ and â€˜write-u8â€™, but not â€˜read-charâ€™ and
     â€˜write-charâ€™ on native binary ports.  (The functions â€˜input-port?â€™,
     â€˜output-port?â€™, â€˜binary-port?â€™, and â€˜port?â€™ all currently return
     false on native binary ports, but that may change.)

 -- Procedure: call-with-port port proc
     The â€˜call-with-portâ€™ procedure calls PROC with port as an argument.
     If PROC returns, then the port is closed automatically and the
     values yielded by the proc are returned.

     If PROC does not return, then the port must not be closed
     automatically unless it is possible to prove that the port will
     never again be used for a read or write operation.

     As a Kawa extension, PORT may be any object that implements
     â€˜java.io.Closeableâ€™.  It is an error if PROC does not accept one
     argument.

 -- Procedure: call-with-input-file path proc
 -- Procedure: call-with-output-file path proc
     These procedures obtain a textual port obtained by opening the
     named file for input or output as if by â€˜open-input-fileâ€™ or
     â€˜open-output-fileâ€™.  The port and PROC are then passed to a
     procedure equivalent to â€˜call-with-portâ€™.

     It is an error if PROC does not accept one argument.

 -- Procedure: input-port? obj
 -- Procedure: output-port? obj
 -- Procedure: textual-port? obj
 -- Procedure: binary-port? obj
 -- Procedure: port? obj
     These procedures return â€˜#tâ€™ if obj is an input port, output port,
     textual port, binary port, or any kind of port, respectively.
     Otherwise they return â€˜#fâ€™.

     These procedures currently return â€˜#fâ€™ on a native Java streams
     (â€˜java.io.InputStreamâ€™ or â€˜java.io.OutputStreamâ€™), a native reader
     (a â€˜java.io.Readerâ€™ that is not an â€˜gnu.mapping.Inportâ€™), or a
     native writer (a â€˜java.io.Writerâ€™ that is not an
     â€˜gnu.mapping.Outportâ€™).  This may change if conversions between
     native ports and Scheme ports becomes more seamless.

 -- Procedure: input-port-open? port
 -- Procedure: output-port-open? port
     Returns â€˜#tâ€™ if PORT is still open and capable of performing input
     or output, respectively, and â€˜#fâ€™ otherwise.  (Not supported for
     native binary ports - i.e.  â€˜java.io.InputStteamâ€™ or
     â€˜java.io.OutputStreamâ€™.)

 -- Procedure: current-input-port
 -- Procedure: current-output-port
 -- Procedure: current-error-port
     Returns the current default input port, output port, or error port
     (an output port), respectively.  (The error port is the the port to
     which errors and warnings should be sent - the "standard error" in
     Unix and C terminology.)  These procedures are *note parameter
     objects: Parameter objects, which can be overridden with *note
     â€˜parameterizeâ€™: parameterize-syntax.

     The initial bindings for â€˜(current-output-port)â€™ and
     â€˜(current-error-port)â€™ are hybrid textual/binary ports that wrap
     the values of the corresponding â€˜java.lang.Systemâ€™ fields â€˜outâ€™,
     and â€˜errâ€™.  The latter, in turn are bound to the standard output
     and error streams of the JVM process.  This means you can write
     binary data to standard output using â€˜write-bytevectorâ€™ and
     â€˜write-u8â€™.

     The initial value â€˜(current-input-port)â€™ similarly is a textual
     port that wraps the â€˜java.lang.Systemâ€™ field â€˜inâ€™, which is bound
     to the standard input stream of the JVM process.  It is a _hybrid_
     textual/binary port only if there is no console (as determined by
     â€˜(java.lang.System:console)â€™ returning â€˜#!nullâ€™) - i.e.  if
     standard input is not a tty.

     Here is an example that copies standard input to standard output:
          (let* ((in (current-input-port))
                 (out (current-output-port))
                 (blen ::int 2048)
                 (buf (make-bytevector blen)))
            (let loop ()
              (define n (read-bytevector! buf in))
              (cond ((not (eof-object? n))
                     (write-bytevector buf out 0 n)
                     (loop)))))

 -- Procedure: with-input-from-file path thunk
 -- Procedure: with-output-to-file path thunk
     The file is opened for input or output as if by â€˜open-input-fileâ€™
     or â€˜open-output-fileâ€™, and the new port is made to be the value
     returned by â€˜current-input-portâ€™ or â€˜current-output-portâ€™ (as used
     by â€˜(read)â€™, â€˜(write OBJ)â€™, and so forth).  The thunk is then
     called with no arguments.  When the THUNK returns, the port is
     closed and the previous default is restored.  It is an error if
     THUNK does not accept zero arguments.  Both procedures return the
     values yielded by THUNK.  If an escape procedure is used to escape
     from the continuation of these procedures, they behave exactly as
     if the current input or output port had been bound dynamically with
     â€˜parameterizeâ€™.

 -- Procedure: open-input-file path
 -- Procedure: open-binary-input-file path
     Takes a PATH naming an existing file and returns a textual input
     port or binary input port that is capable of delivering data from
     the file.

     The procedure â€˜open-input-fileâ€™ checks the fluid variable *note
     â€˜port-char-encodingâ€™: port-char-encoding. to determine how bytes
     are decoded into characters.  The procedure
     â€˜open-binary-input-fileâ€™ is equivalent to calling â€˜open-input-fileâ€™
     with â€˜port-char-encodingâ€™ set to â€˜#fâ€™.

 -- Procedure: open-output-file path
 -- Procedure: open-binary-output-file path
     Takes a PATH naming an output file to be created and returns
     respectively a textual output port or binary output port that is
     capable of writing data to a new file by that name.  If a file with
     the given name already exists, the effect is unspecified.

     The procedure â€˜open-output-fileâ€™ checks the fluid variable *note
     â€˜port-char-encodingâ€™: port-char-encoding. to determine how
     characters are encoded as bytes.  The procedure
     â€˜open-binary-output-fileâ€™ is equivalent to calling
     â€˜open-output-fileâ€™ with â€˜port-char-encodingâ€™ set to â€˜#fâ€™.

 -- Procedure: close-port port
 -- Procedure: close-input-port port
 -- Procedure: close-output-port port
     Closes the resource associated with PORT, rendering the port
     incapable of delivering or accepting data.  It is an error to apply
     the last two procedures to a port which is not an input or output
     port, respectively.  (Specifically, â€˜close-input-portâ€™ requires a
     â€˜java.io.Readerâ€™, while â€˜close-output-portâ€™ requires a
     â€˜java.io.Writerâ€™.  In contrast â€˜close-portâ€™ accepts any object
     whose class implements â€˜java.io.Closeableâ€™.)

     These routines have no effect if the port has already been closed.

16.5.1 String and bytevector ports
----------------------------------

 -- Procedure: open-input-string string
     Takes a string and returns a text input port that delivers
     characters from the string.  The port can be closed by
     â€˜close-input-portâ€™, though its storage will be reclaimed by the
     garbage collector if it becomes inaccessible.

          (define p
            (open-input-string "(a . (b c . ())) 34"))

          (input-port? p)                 â‡’  #t
          (read p)                        â‡’  (a b c)
          (read p)                        â‡’  34
          (eof-object? (peek-char p))     â‡’  #t

 -- Procedure: open-output-string
     Returns an textual output port that will accumulate characters for
     retrieval by â€˜get-output-stringâ€™.  The port can be closed by the
     procedure â€˜close-output-portâ€™, though its storage will be reclaimed
     by the garbage collector if it becomes inaccessible.
          (let ((q (open-output-string))
            (x '(a b c)))
              (write (car x) q)
              (write (cdr x) q)
              (get-output-string q))        â‡’  "a(b c)"

 -- Procedure: get-output-string output-port
     Given an output port created by â€˜open-output-stringâ€™, returns a
     string consisting of the characters that have been output to the
     port so far in the order they were output.  If the result string is
     modified, the effect is unspecified.

          (parameterize
              ((current-output-port (open-output-string)))
              (display "piece")
              (display " by piece ")
              (display "by piece.")
              (newline)
              (get-output-string (current-output-port)))
                  â‡’ "piece by piece by piece.\n"

 -- Procedure: call-with-input-string string proc
     Create an input port that gets its data from STRING, call PROC with
     that port as its one argument, and return the result from the call
     of PROC

 -- Procedure: call-with-output-string proc
     Create an output port that writes its data to a STRING, and call
     PROC with that port as its one argument.  Return a string
     consisting of the data written to the port.

 -- Procedure: open-input-bytevector bytevector
     Takes a bytevector and returns a binary input port that delivers
     bytes from the bytevector.

 -- Procedure: open-output-bytevector
     Returns a binary output port that will accumulate bytes for
     retrieval by â€˜get-output-bytevectorâ€™.

 -- Procedure: get-output-bytevector port
     Returns a bytevector consisting of the bytes that have been output
     to the port so far in the order they were output.  It is an error
     if PORT was not created with â€˜open-output-bytevectorâ€™.

16.5.2 Input
------------

If PORT is omitted from any input procedure, it defaults to the value
returned by â€˜(current-input-port)â€™.  It is an error to attempt an input
operation on a closed port.

 -- Procedure: read [port]
     The â€˜readâ€™ procedure converts external representations of Scheme
     objects into the objects themselves.  That is, it is a parser for
     the non-terminal DATUM.  It returns the next object parsable from
     the given textual input port, updating port to point to the first
     character past the end of the external representation of the
     object.

     If an end of file is encountered in the input before any characters
     are found that can begin an object, then an end-of-file object is
     returned.  The port remains open, and further attempts to read will
     also return an end-of-file object.  If an end of file is
     encountered after the beginning of an objectâ€™s external
     representation, but the external representation is incomplete and
     therefore not parsable, an error that satisfies â€˜read-error?â€™ is
     signaled.

 -- Procedure: read-char [port]
     Returns the next character available from the textual input PORT,
     updating the port to point to the following character.  If no more
     characters are available, an end-of-file value is returned.

     The result type is â€˜character-or-eofâ€™.

 -- Procedure: peek-char [port]
     Returns the next character available from the textual input PORT,
     but _without_ updating the port to point to the following
     character.  If no more characters are available, an end-of-file
     value is returned.

     The result type is â€˜character-or-eofâ€™.

     _Note:_ The value returned by a call to â€˜peek-charâ€™ is the same as
     the value that would have been returned by a call to â€˜read-charâ€™
     with the same PORT.  The only difference is that the very next call
     to â€˜read-charâ€™ or â€˜peek-charâ€™ on that PORT will return the value
     returned by the preceding call to â€˜peek-charâ€™.  In particular, a
     call to â€˜peek-charâ€™ on an interactive port will hang waiting for
     input whenever a call to â€˜read-charâ€™ would have hung.

 -- Procedure: read-line [port [handle-newline]]
     Reads a line of input from the textual input PORT.  The
     HANDLE-NEWLINE parameter determines what is done with terminating
     end-of-line delimiter.  The default, â€˜'trimâ€™, ignores the
     delimiter; â€˜'peekâ€™ leaves the delimiter in the input stream;
     â€˜'concatâ€™ appends the delimiter to the returned value; and â€˜'splitâ€™
     returns the delimiter as a second value.  You can use the last
     three options to tell if the string was terminated by end-or-line
     or by end-of-file.  If an end of file is encountered before any end
     of line is read, but some characters have been read, a string
     containing those characters is returned.  (In this case, â€˜'trimâ€™,
     â€˜'peekâ€™, and â€˜'concatâ€™ have the same result and effect.  The
     â€˜'splitâ€™ case returns two values: The characters read, and the
     delimiter is an empty string.)  If an end of file is encountered
     before any characters are read, an end-of-file object is returned.
     For the purpose of this procedure, an end of line consists of
     either a linefeed character, a carriage return character, or a
     sequence of a carriage return character followed by a linefeed
     character.

 -- Pocedure: eof-object? obj
     Returns â€˜#tâ€™ if OBJ is an end-of-file object, otherwise returns
     â€˜#fâ€™.

     â€˜Performance noteâ€™: If OBJ has type â€˜character-or-eofâ€™, this is
     compiled as an â€˜intâ€™ comparison with -1.

 -- Procedure: eof-object
     Returns an end-of-file object.

 -- Procedure: char-ready? [port]
     Returns â€˜#tâ€™ if a character is ready on the textual input PORT and
     returns â€˜#fâ€™ otherwise.  If char-ready returns â€˜#tâ€™ then the next
     â€˜read-charâ€™ operation on the given PORT is guaranteed not to hang.
     If the port is at end of file then â€˜char-ready?â€™ returns â€˜#tâ€™.

     _Rationale:_ The â€˜char-ready?â€™ procedure exists to make it possible
     for a program to accept characters from interactive ports without
     getting stuck waiting for input.  Any input editors as- sociated
     with such ports must ensure that characters whose existence has
     been asserted by â€˜char-ready?â€™ cannot be removed from the input.
     If â€˜char-ready?â€™ were to return â€˜#fâ€™ at end of file, a port at
     end-of-file would be indistinguishable from an interactive port
     that has no ready characters.

 -- Procedure: read-string k [port]
     Reads the next K characters, or as many as are available before the
     end of file, from the textual input PORT into a newly allocated
     string in left-to-right order and returns the string.  If no
     characters are available before the end of file, an end-of-file
     object is returned.

 -- Procedure: read-u8 [port]
     Returns the next byte available from the binary input PORT,
     updating the PORT to point to the following byte.  If no more bytes
     are available, an end-of-file object is returned.

 -- Procedure: peek-u8 [port]
     Returns the next byte available from the binary input PORT, but
     _without_ updating the PORT to point to the following byte.  If no
     more bytes are available, an end-of-file object is returned.

 -- Procedure: u8-ready? [port]
     Returns â€˜#tâ€™ if a byte is ready on the binary input PORT and
     returns â€˜#fâ€™ otherwise.  If â€˜u8-ready?â€™ returns â€˜#tâ€™ then the next
     â€˜read-u8â€™ operation on the given port is guaranteed not to hang.
     If the port is at end of file then â€˜u8-ready?â€™ returns â€˜#tâ€™.

 -- Procedure: read-bytevector k [port]
     Reads the next K bytes, or as many as are available before the end
     of file, from the binary input PORT into a newly allocated
     bytevector in left-to-right order and returns the bytevector.  If
     no bytes are available before the end of file, an end-of-file
     object is returned.

 -- Procedure: read-bytevector! bytevector [port [start [end]]]
     Reads the next END âˆ’ START bytes, or as many as are available
     before the end of file, from the binary input PORT into BYTEVECTOR
     in left-to-right order beginning at the START position.  If END is
     not supplied, reads until the end of BYTEVECTOR has been reached.
     If START is not supplied, reads beginning at position 0.  Returns
     the number of bytes read.  If no bytes are available, an
     end-of-file object is returned.

16.5.3 Output
-------------

If PORT is omitted from any output procedure, it defaults to the value
returned by â€˜(current-output-port)â€™.  It is an error to attempt an
output operation on a closed port.

   The return type of these methods is â€˜voidâ€™.

 -- Procedure: write obj [port]
     Writes a representation of OBJ to the given textual output PORT.
     Strings that appear in the written representation are enclosed in
     quotation marks, and within those strings backslash and quotation
     mark characters are escaped by backslashes.  Symbols that contain
     non-ASCII characters are escaped with vertical lines.  Character
     objects are written using the â€˜#\â€™ notation.

     If OBJ contains cycles which would cause an infinite loop using the
     normal written representation, then at least the objects that form
     part of the cycle must be represented using *note datum labels::.
     Datum labels must not be used if there are no cycles.

 -- Procedure: write-shared obj [port]
     The â€˜write-sharedâ€™ procedure is the same as â€˜writeâ€™, except that
     shared structure must be represented using datum labels for all
     pairs and vectors that appear more than once in the output.

 -- Procedure: write-simple obj [port]
     The â€˜write-simpleâ€™ procedure is the same as â€˜writeâ€™, except that
     shared structure is never represented using datum labels.  This can
     cause write-simple not to terminate if OBJ contains circular
     structure.

 -- Procedure: display obj [port]
     Writes a representation of OBJ to the given textual output port.
     Strings that appear in the written representation are output as if
     by â€˜write-stringâ€™ instead of by â€˜writeâ€™.  Symbols are not escaped.
     Character objects appear in the representation as if written by
     â€˜write-charâ€™ instead of by â€˜writeâ€™.  The â€˜displayâ€™ representation
     of other objects is unspecified.

 -- Procedure: newline [port]
     Writes an end of line to textual output PORT.  This is done using
     the â€˜printlnâ€™ method of the Java class â€˜java.io.PrintWriterâ€™.

 -- Procedure: write-char char [port]
     Writes the character CHAR (not an external representation of the
     character) to the given textual output PORT.

 -- Procedure: write-string string [port [start [end]]]
     Writes the characters of STRING from START to END in left-to-right
     order to the textual output PORT.

 -- Procedure: write-u8 byte [port]
     Writes the BYTE to the given binary output port.

 -- Procedure: write-bytevector bytevector [port [start [end]]]
     Writes the bytes of BYTEVECTOR from START to END in left-to-right
     order to the binary output PORT.

 -- Procedure: flush-output-port [port]
 -- Procedure: force-output [port]
     Forces any pending output on PORT to be delivered to the output
     file or device and returns an unspecified value.  If the PORT
     argument is omitted it defaults to the value returned by
     â€˜(current-output-port)â€™.  (The name â€˜force-outputâ€™ is older, while
     R6RS added â€˜flush-output-portâ€™.  They have the same effect.)

16.5.4 Line numbers and other input port properties
---------------------------------------------------

An interactive input port has a prompt procedure associated with it.
The prompt procedure is called before a new line is read.  It is passed
the port as an argument, and returns a string, which gets printed as a
prompt.

 -- Procedure: input-port-prompter port
     Get the prompt procedure associated with PORT.

 -- Procedure: set-input-port-prompter! port prompter
     Set the prompt procedure associated with PORT to PROMPTER, which
     must be a one-argument procedure taking an input port, and
     returning a string.

 -- Procedure: default-prompter port
     The default prompt procedure.  It returns â€˜"#|kawa:L|# "â€™, where L
     is the current line number of PORT.  When reading a continuation
     line, the result is â€˜"#|C---:L|# "â€™, where â€˜Câ€™ is the character
     returned by â€˜(input-port-read-state PORT)â€™.  The prompt has the
     form of a comment to make it easier to cut-and-paste.

 -- Function: port-column input-port
 -- Function: port-line input-port
     Return the current column number or line number of INPUT-PORT,
     using the current input port if none is specified.  If the number
     is unknown, the result is â€˜#fâ€™.  Otherwise, the result is a
     0-origin integer - i.e.  the first character of the first line is
     line 0, column 0.  (However, when you display a file position, for
     example in an error message, we recommend you add 1 to get 1-origin
     integers.  This is because lines and column numbers traditionally
     start with 1, and that is what non-programmers will find most
     natural.)

 -- Procedure: set-port-line! port line
     Set (0-origin) line number of the current line of PORT to NUM.

 -- Procedure: input-port-line-number port
     Get the line number of the current line of PORT, which must be a
     (non-binary) input port.  The initial line is line 1.  Deprecated;
     replaced by â€˜(+ 1 (port-line PORT))â€™.

 -- Procedure: set-input-port-line-number! port num
     Set line number of the current line of PORT to NUM.  Deprecated;
     replaced by â€˜(set-port-line! PORT (- NUM 1))â€™.

 -- Procedure: input-port-column-number port
     Get the column number of the current line of PORT, which must be a
     (non-binary) input port.  The initial column is column 1.
     Deprecated; replaced by â€˜(+ 1 (port-column PORT))â€™.

 -- Procedure: input-port-read-state port
     Returns a character indicating the current â€˜readâ€™ state of the
     PORT.  Returns â€˜#\Returnâ€™ if not current doing a READ, â€˜#\"â€™ if
     reading a string; â€˜#\|â€™ if reading a comment; â€˜#\(â€™ if inside a
     list; and â€˜#\Spaceâ€™ when otherwise in a â€˜readâ€™.  The result is
     intended for use by prompt prcedures, and is not necessarily
     correct except when reading a new-line.

 -- Variable: symbol-read-case
     A symbol that controls how â€˜readâ€™ handles letters when reading a
     symbol.  If the first letter is â€˜Uâ€™, then letters in symbols are
     upper-cased.  If the first letter is â€˜Dâ€™ or â€˜Lâ€™, then letters in
     symbols are down-cased.  If the first letter is â€˜Iâ€™, then the case
     of letters in symbols is inverted.  Otherwise (the default), the
     letter is not changed.  (Letters following a â€˜\â€™ are always
     unchanged.)  The value of â€˜symbol-read-caseâ€™ only checked when a
     reader is created, not each time a symbol is read.

16.5.5 Miscellaeous
-------------------

 -- Variable: port-char-encoding
     Controls how bytes in external files are converted to/from internal
     Unicode characters.  Can be either a symbol or a boolean.  If
     â€˜port-char-encodingâ€™ is â€˜#fâ€™, the file is assumed to be a binary
     file and no conversion is done.  Otherwise, the file is a text
     file.  The default is â€˜#tâ€™, which uses a locale-dependent
     conversion.  If â€˜port-char-encodingâ€™ is a symbol, it must be the
     name of a character encoding known to Java.  For all text files
     (that is if â€˜port-char-encodingâ€™ is not â€˜#fâ€™), on input a
     â€˜#\Returnâ€™ character or a â€˜#\Returnâ€™ followed by â€˜#\Newlineâ€™ are
     converted into plain â€˜#\Newlineâ€™.

     This variable is checked when the file is opened; not when actually
     reading or writing.  Here is an example of how you can safely
     change the encoding temporarily:
          (define (open-binary-input-file name)
            (fluid-let ((port-char-encoding #f)) (open-input-file name)))

 -- Variable: *print-base*
     The number base (radix) to use by default when printing rational
     numbers.  Must be an integer between 2 and 36, and the default is
     of course 10.  For example setting â€˜*print-base*â€™ to 16 produces
     hexadecimal output.

 -- Variable: *print-radix*
     If true, prints an indicator of the radix used when printing
     rational numbers.  If â€˜*print-base*â€™ is respectively 2, 8, or 16,
     then â€˜#bâ€™, â€˜#oâ€™ or â€˜#xâ€™ is written before the number; otherwise
     â€˜#Nrâ€™ is written, where â€˜Nâ€™ is the base.  An exception is when
     â€˜*print-base*â€™ is 10, in which case a period is written _after_ the
     number, to match Common Lisp; this may be inappropriate for Scheme,
     so is likely to change.

 -- Variable: *print-right-margin*
     The right margin (or line width) to use when pretty-printing.

 -- Variable: *print-miser-width*
     If this an integer, and the available width is less or equal to
     this value, then the pretty printer switch to the more "miser"
     compact style.

 -- Variable: *print-xml-indent*
     When writing to XML, controls pretty-printing and indentation.  If
     the value is â€˜'alwaysâ€™ or â€˜'yesâ€™ force each element to start on a
     new suitably-indented line.  If the value is â€˜'prettyâ€™ only force
     new lines for elements that wonâ€™t fit completely on a line.  The
     the value is â€˜'noâ€™ or unset, donâ€™t add extra whitespace.


File: kawa.info,  Node: Format,  Prev: Ports,  Up: Input-Output

16.6 Formatted Output (Common-Lisp-style)
=========================================

 -- Procedure: format destination fmt . arguments
     An almost complete implementation of Common LISP format description
     according to the CL reference book â€˜Common LISPâ€™ from Guy L.
     Steele, Digital Press.  Backward compatible to most of the
     available Scheme format implementations.

     Returns â€˜#tâ€™, â€˜#fâ€™ or a string; has side effect of printing
     according to FMT.  If DESTINATION is â€˜#tâ€™, the output is to the
     current output port and â€˜#!voidâ€™ is returned.  If DESTINATION is
     â€˜#fâ€™, a formatted string is returned as the result of the call.  If
     DESTINATION is a string, DESTINATION is regarded as the format
     string; FMT is then the first argument and the output is returned
     as a string.  If DESTINATION is a number, the output is to the
     current error port if available by the implementation.  Otherwise
     DESTINATION must be an output port and â€˜#!voidâ€™ is returned.

     FMT must be a string or an instance of â€˜gnu.text.MessageFormatâ€™ or
     â€˜java.text.MessageFormatâ€™.  If FMT is a string, it is parsed as if
     by â€˜parse-formatâ€™.

 -- Procedure: parse-format format-string
     Parses â€˜format-stringâ€™, which is a string of the form of a Common
     LISP format description.  Returns an instance of
     â€˜gnu.text.ReportFormatâ€™, which can be passed to the â€˜formatâ€™
     function.

   A format string passed to â€˜formatâ€™ or â€˜parse-formatâ€™ consists of
format directives (that start with â€˜~â€™), and regular characters (that
are written directly to the destination).  Most of the Common Lisp (and
Slib) format directives are implemented.  Neither justification, nor
pretty-printing are supported yet.

   Plus of course, we need documentation for â€˜formatâ€™!

16.6.1 Implemented CL Format Control Directives
-----------------------------------------------

Documentation syntax: Uppercase characters represent the corresponding
control directive characters.  Lowercase characters represent control
directive parameter descriptions.

â€˜~Aâ€™
     Any (print as â€˜displayâ€™ does).
     â€˜~@Aâ€™
          left pad.
     â€˜~MINCOL,COLINC,MINPAD,PADCHARAâ€™
          full padding.
â€˜~Sâ€™
     S-expression (print as â€˜writeâ€™ does).
     â€˜~@Sâ€™
          left pad.
     â€˜~MINCOL,COLINC,MINPAD,PADCHARSâ€™
          full padding.

â€˜~Câ€™
     Character.
     â€˜~@Câ€™
          prints a character as the reader can understand it (i.e.  â€˜#\â€™
          prefixing).
     â€˜~:Câ€™
          prints a character as emacs does (eg.  â€˜^Câ€™ for ASCII 03).

16.6.2 Formatting Integers
--------------------------

â€˜~Dâ€™
     Decimal.
     â€˜~@Dâ€™
          print number sign always.
     â€˜~:Dâ€™
          print comma separated.
     â€˜~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHDâ€™
          padding.
â€˜~Xâ€™
     Hexadecimal.
     â€˜~@Xâ€™
          print number sign always.
     â€˜~:Xâ€™
          print comma separated.
     â€˜~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHXâ€™
          padding.
â€˜~Oâ€™
     Octal.
     â€˜~@Oâ€™
          print number sign always.
     â€˜~:Oâ€™
          print comma separated.
     â€˜~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHOâ€™
          padding.
â€˜~Bâ€™
     Binary.
     â€˜~@Bâ€™
          print number sign always.
     â€˜~:Bâ€™
          print comma separated.
     â€˜~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHBâ€™
          padding.
â€˜~NRâ€™
     Radix N.
     â€˜~N,MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHRâ€™
          padding.
â€˜~@Râ€™
     print a number as a Roman numeral.
â€˜~:@Râ€™
     print a number as an â€œold fashionedâ€ Roman numeral.
â€˜~:Râ€™
     print a number as an ordinal English number.
â€˜~Râ€™
     print a number as a cardinal English number.
â€˜~Pâ€™
     Plural.
     â€˜~@Pâ€™
          prints â€˜yâ€™ and â€˜iesâ€™.
     â€˜~:Pâ€™
          as â€˜~P but jumps 1 argument backward.â€™
     â€˜~:@Pâ€™
          as â€˜~@P but jumps 1 argument backward.â€™

   COMMAWIDTH is the number of characters between two comma characters.

16.6.3 Formatting real numbers
------------------------------

â€˜~Fâ€™
     Fixed-format floating-point (prints a flonum like MMM.NNN).
     â€˜~WIDTH,DIGITS,SCALE,OVERFLOWCHAR,PADCHARFâ€™
     â€˜~@Fâ€™
          If the number is positive a plus sign is printed.

â€˜~Eâ€™
     Exponential floating-point (prints a flonum like MMM.NNNâ€˜Eâ€™EE)
     â€˜~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHAREâ€™
     â€˜~@Eâ€™
          If the number is positive a plus sign is printed.

â€˜~Gâ€™
     General floating-point (prints a flonum either fixed or
     exponential).
     â€˜~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARGâ€™
     â€˜~@Gâ€™
          If the number is positive a plus sign is printed.
     A slight difference from Common Lisp: If the number is printed in
     fixed form and the fraction is zero, then a zero digit is printed
     for the fraction, if allowed by the WIDTH and DIGITS is
     unspecified.

â€˜~$â€™
     Dollars floating-point (prints a flonum in fixed with signs
     separated).
     â€˜~DIGITS,SCALE,WIDTH,PADCHAR$â€™
     â€˜~@$â€™
          If the number is positive a plus sign is printed.
     â€˜~:@$â€™
          A sign is always printed and appears before the padding.
     â€˜~:$â€™
          The sign appears before the padding.

16.6.4 Miscellaneous formatting operators
-----------------------------------------

â€˜~%â€™
     Newline.
     â€˜~N%â€™
          print N newlines.
â€˜~&â€™
     print newline if not at the beginning of the output line.
     â€˜~N&â€™
          prints â€˜~&â€™ and then N-1 newlines.
â€˜~|â€™
     Page Separator.
     â€˜~N|â€™
          print N page separators.
â€˜~~â€™
     Tilde.
     â€˜~N~â€™
          print N tildes.
â€˜~â€™<newline>
     Continuation Line.
     â€˜~:â€™<newline>
          newline is ignored, white space left.
     â€˜~@â€™<newline>
          newline is left, white space ignored.
â€˜~Tâ€™
     Tabulation.
     â€˜~@Tâ€™
          relative tabulation.
     â€˜~COLNUM,COLINCTâ€™
          full tabulation.
â€˜~?â€™
     Indirection (expects indirect arguments as a list).
     â€˜~@?â€™
          extracts indirect arguments from format arguments.
â€˜~(STR~)â€™
     Case conversion (converts by â€˜string-downcaseâ€™).
     â€˜~:(STR~)â€™
          converts by â€˜string-capitalizeâ€™.
     â€˜~@(STR~)â€™
          converts by â€˜string-capitalize-firstâ€™.
     â€˜~:@(STR~)â€™
          converts by â€˜string-upcaseâ€™.
â€˜~*â€™
     Argument Jumping (jumps 1 argument forward).
     â€˜~N*â€™
          jumps N arguments forward.
     â€˜~:*â€™
          jumps 1 argument backward.
     â€˜~N:*â€™
          jumps N arguments backward.
     â€˜~@*â€™
          jumps to the 0th argument.
     â€˜~N@*â€™
          jumps to the Nth argument (beginning from 0)
â€˜~[STR0~;STR1~;...~;STRN~]â€™
     Conditional Expression (numerical clause conditional).
     â€˜~N[â€™
          take argument from N.
     â€˜~@[â€™
          true test conditional.
     â€˜~:[â€™
          if-else-then conditional.
     â€˜~;â€™
          clause separator.
     â€˜~:;â€™
          default clause follows.
â€˜~{STR~}â€™
     Iteration (args come from the next argument (a list)).
     â€˜~N{â€™
          at most N iterations.
     â€˜~:{â€™
          args from next arg (a list of lists).
     â€˜~@{â€™
          args from the rest of arguments.
     â€˜~:@{â€™
          args from the rest args (lists).
â€˜~^â€™
     Up and out.
     â€˜~N^â€™
          aborts if N = 0
     â€˜~N,M^â€™
          aborts if N = M
     â€˜~N,M,K^â€™
          aborts if N <= M <= K

16.6.5 Unimplemented CL Format Control Directives
-------------------------------------------------

â€˜~:Aâ€™
     print â€˜#fâ€™ as an empty list (see below).
â€˜~:Sâ€™
     print â€˜#fâ€™ as an empty list (see below).
â€˜~<~>â€™
     Justification.
â€˜~:^â€™

16.6.6 Extended, Replaced and Additional Control Directives
-----------------------------------------------------------

These are not necesasrily implemented in Kawa!

â€˜~Iâ€™
     print a R4RS complex number as â€˜~F~@Fiâ€™ with passed parameters for
     â€˜~Fâ€™.
â€˜~Yâ€™
     Pretty print formatting of an argument for scheme code lists.
â€˜~Kâ€™
     Same as â€˜~?.â€™
â€˜~!â€™
     Flushes the output if format DESTINATION is a port.
â€˜~_â€™
     Print a â€˜#\spaceâ€™ character
     â€˜~N_â€™
          print N â€˜#\spaceâ€™ characters.

â€˜~NCâ€™
     Takes N as an integer representation for a character.  No arguments
     are consumed.  N is converted to a character by â€˜integer->charâ€™.  N
     must be a positive decimal number.
â€˜~:Sâ€™
     Print out readproof.  Prints out internal objects represented as
     â€˜#<...>â€™ as strings â€˜"#<...>"â€™ so that the format output can always
     be processed by â€˜readâ€™.
â€˜~:Aâ€™
     Print out readproof.  Prints out internal objects represented as
     â€˜#<...>â€™ as strings â€˜"#<...>"â€™ so that the format output can always
     be processed by â€˜readâ€™.
â€˜~F, ~E, ~G, ~$â€™
     may also print number strings, i.e.  passing a number as a string
     and format it accordingly.


File: kawa.info,  Node: Resources,  Prev: Format,  Up: Input-Output

16.7 Resources
==============

A resource is a file or other fixed data that an application may access.
Resources are part of the application and are shipped with it, but are
stored in external files.  Examples are images, sounds, and translation
(localization) of messages.  In the Java world a resource is commonly
bundled in the same jar file as the application itself.

 -- Syntax: resource-url resource-name
     Returns a â€˜URLPathâ€™ you can use as a â€˜URLâ€™, or you can pass to it
     â€˜open-input-fileâ€™ to read the resource data.  The RESOURCE-NAME is
     a string which is passed to the â€˜ClassLoaderâ€™ of the containing
     module.  If the module class is in a jar file, things will
     magically work if the resource is in the same jar file, and
     RESOURCE-NAME is a filename relative to the module class in the
     jar.  If the module is immediately evaluated, the RESOURCE-NAME is
     resolved against the location of the module source file.

 -- Syntax: module-uri
     Evaluates to a special URI that can be used to access resources
     relative to the class of the containing module.  The URI has the
     form â€˜"class-resource://CURRENTCLASS/"â€™ in compiled code, to allow
     moving the classes/jars.  The current â€˜ClassLoaderâ€™ is associated
     with the URI, so accessing resources using the URI will use that
     â€˜ClassLoaderâ€™.  Therefore you should not create a
     â€˜"class-resource:"â€™ URI except by using this function or
     â€˜resolve-uriâ€™, since that might try to use the wrong â€˜ClassLoaderâ€™.

     The macro â€˜resource-urlâ€™ works by using â€˜module-uriâ€™ and resolving
     that to a normal â€˜URLâ€™.


File: kawa.info,  Node: Types,  Next: Objects Classes and Modules,  Prev: Input-Output,  Up: Top

17 Types
********

A "type" is a set of values, plus an associated set of operations valid
on those values.  Types are useful for catching errors
("type-checking"), documenting the programmerâ€™s intent, and to help the
compiler generate better code.  Types in some languages (such as C)
appear in programs, but do not exist at run-time.  In such languages,
all type-checking is done at compile-time.  Other languages (such as
standard Scheme) do not have types as such, but they have "predicates",
which allow you to check if a value is a member of certain sets; also,
the primitive functions will check at run-time if the arguments are
members of the allowed sets.  Other languages, including Java and Common
Lisp, provide a combination: Types may be used as specifiers to guide
the compiler, but also exist as actual run-time values.  In Java, for
each class, there is a corresponding â€˜java.lang.Classâ€™ run-time object,
as well as an associated type (the set of values of that class, plus its
sub-classes, plus â€˜nullâ€™).

   Kawa, like Java, has first-class types, that is types exist as
objects you can pass around at run-time.  For each Java type, there is a
corresponding Kawa type (but not necessarily vice versa).  It would be
nice if we could represent run-time type values using â€˜java.lang.Classâ€™
objects, but unfortunately that does not work very well.  One reason is
that we need to be able to refer to types and classes that do not exist
yet, because we are in the processing of compiling them.  Another reason
is that we want to be able to distinuish between different types that
are implemented using the same Java class.

   Various Kawa constructs require or allow a type to be specified.
Those specifications consist of "type expressions", which is evaluated
to yield a type value.  The current Kawa compiler is rather
simple-minded, and in many places only allows simple types that the
compiler can evaluate at compile-time.  More specifically, it only
allows simple "type names" that map to primitive Java types or java
classes.

     TYPE ::= EXPRESSION
     OPT-TYPE-SPECIFIER ::= [â€˜::â€™ TYPE]

* Menu:

* Standard Types::
* Parameterized Types::
* Type tests and conversions::


File: kawa.info,  Node: Standard Types,  Next: Parameterized Types,  Up: Types

17.1 Standard Types
===================

These types are predefined with the following names.

   Instead of plain â€˜TYPENAMEâ€™ you can also use the syntax â€˜<TYPENAME>â€™
with angle brackets, but that syntax is no longer recommended, because
it doesnâ€™t â€œfitâ€ as well with some ways type names are used.

   To find which Java classes these types map into, look in
â€˜kawa/standard/Scheme.javaâ€™.

   Note that the value of these variables are instances of
â€˜gnu.bytecode.Typeâ€™, not (as you might at first expect)
â€˜java.lang.Classâ€™.

   The numeric types (â€˜numberâ€™, â€˜quantityâ€™, â€˜complexâ€™, â€˜realâ€™,
â€˜rationalâ€™, â€˜integerâ€™, â€˜longâ€™, â€˜intâ€™, â€˜shortâ€™, â€˜byteâ€™ â€˜ulongâ€™, â€˜uintâ€™,
â€˜ushortâ€™, â€˜ubyteâ€™, â€˜doubleâ€™, â€˜floatâ€™) are discussed in *note Numerical
types::.

   The types â€˜characterâ€™ and â€˜charâ€™ are discussed in *note Characters::.

 -- Variable: Object
     An arbitrary Scheme value - and hence an arbitrary Java object.

 -- Variable: symbol
     The type of Scheme symbols.  (Implemented using the Java class
     â€˜gnu.mapping.Symbolâ€™.)  (Compatibility note: Previous versions of
     Kawa implemented a simple Scheme symbol using an interned
     â€˜java.lang.Stringâ€™.)

 -- Variable: keyword
     The type of keyword values.  *Note Keywords::.

 -- Variable: list
     The type of Scheme lists (pure and impure, including the empty
     list).

 -- Variable: pair
     The type of Scheme pairs.  This is a sub-type of â€˜listâ€™.

 -- Variable: string
     The type of Scheme strings.  (Implemented using â€˜java.lang.Stringâ€™
     for immutable strings, and â€˜gnu.lists.FStringâ€™ for mutable strings.
     Both of these implement the interface â€˜java.lang.CharSequenceâ€™.  In
     the future, we may change the representation for strings containing
     â€œsurrogate charactersâ€, for efficient indexing.)  (Compatibility
     note: Previous versions of Kawa implemented always used
     â€˜gnu.lists.FStringâ€™.)

 -- Variable: character
     The type of Scheme character values.  This is a sub-type of
     â€˜Objectâ€™, in contrast to type â€˜charâ€™, which is the primitive Java
     â€˜charâ€™ type.

 -- Variable: vector
     The type of Scheme vectors.

 -- Variable: procedure
     The type of Scheme procedures.

 -- Variable: input-port
     The type of Scheme input ports.

 -- Variable: output-port
     The type of Scheme output ports.

 -- Variable: String
     This type name is a special case.  It specifies the class
     â€˜java.lang.Stringâ€™.  However, coercing a value to â€˜Stringâ€™ is done
     by invoking the â€˜toStringâ€™ method on the value to be coerced.  Thus
     it "works" for all objects.  It also works for â€˜#!nullâ€™.

     When Scheme code invokes a Java methods any parameter whose type is
     â€˜java.lang.Stringâ€™ is converted as if it was declared as a
     â€˜Stringâ€™.

 -- Variable: parameter
     A parameter object, as created by â€˜make-parameterâ€™.  This type can
     take a type parameter (sic):
          (define-constant client ::parameter[Client] (make-parameter #!null))
     This lets Kawa know that reading the parameter (as in â€˜(client)â€™
     return a value of the specified type (in this case â€˜Clientâ€™).

   More will be added later.

   A type specifier can also be one of the primitive Java types.  The
numeric types â€˜longâ€™, â€˜intâ€™, â€˜shortâ€™, â€˜byteâ€™, â€˜floatâ€™, and â€˜doubleâ€™ are
converted from the corresponding Scheme number classes.  Similarly,
â€˜charâ€™ can be converted to and from Scheme characters.  The type
â€˜booleanâ€™ matches any object, and the result is â€˜falseâ€™ if and only if
the actual argument is â€˜#fâ€™.  (The value â€˜#fâ€™ is identical to
â€˜Boolean.FALSEâ€™, and â€˜#tâ€™ is identical to â€˜Boolean.TRUEâ€™.)  The return
type â€˜voidâ€™ indicates that no value is returned.

   A type specifier can also be a fully-qualified Java class name (for
example â€˜java.lang.StringBufferâ€™).  In that case, the actual argument is
cast at run time to the named class.  Also, â€˜java.lang.StringBuffer[]â€™
represents an array of references to â€˜java.lang.StringBufferâ€™ objects.

 -- Variable: dynamic
     Used to specify that the type is unknown, and is likely to change
     at run-time.  Warnings about unknown member names are supressed (a
     run-time name lookup is formed).  An expression of type â€˜dynamicâ€™
     is (statically) compatible with any type.


File: kawa.info,  Node: Parameterized Types,  Next: Type tests and conversions,  Prev: Standard Types,  Up: Types

17.2 Parameterized Types
========================

Kawa has some basic support for parameterized (generic) types.  The
syntax:
     Type[Arg1 Arg2 ... ArgN]
   is more-or-less equivalent to Javaâ€™s:
     Type<Arg1, Arg2, ..., ArgN>

   This is a work-in-progress.  You can use this syntax with
fully-qualified class names, and also type aliases:
     (define v1 ::gnu.lists.FVector[gnu.math.IntNum] [4 5 6])
     (define-alias fv gnu.lists.FVector)
     (define v2 ::fv[integer] [5 6 7])
     (define-alias fvi fv[integer])
     (define v3 ::fvi [6 7 8])


File: kawa.info,  Node: Type tests and conversions,  Prev: Parameterized Types,  Up: Types

17.3 Type tests and conversions
===============================

Scheme defines a number of standard type testing predicates.  For
example â€˜(vector? x)â€™ is â€˜#tâ€™ if and only if â€˜xâ€™ is a vector.

   Kawa generalizes this to arbitrary type names: If T is a type-name
(that is in scope at compile-time), then â€˜T?â€™ is a one-argument function
that returns â€˜#tâ€™ if the argument is an instance of the type â€˜Tâ€™, and
â€˜#fâ€™ otherwise:
     (gnu.lists.FVector? #(123)) â‡’ #t
     (let ((iarr (int[] 10))) (int[]? iarr)) â‡’ #t

   To convert (coerce) the result of an expression VALUE to a type T use
the syntax: â€˜(->T VALUE)â€™.
     (->float 12) â‡’ 12.0f0

   In general:
     (T? X) â‡’ (instance? X T)
     (->T X) â‡’ (as T X)

 -- Procedure: instance? value type
     Returns â€˜#tâ€™ iff VALUE is an instance of type TYPE.  (Undefined if
     TYPE is a primitive type, such as â€˜intâ€™.)

 -- Procedure: as type value
     Converts or coerces VALUE to a value of type TYPE.  Throws an
     exception if that cannot be done.  Not supported for TYPE to be a
     primitive type such as â€˜<int>â€™.


File: kawa.info,  Node: Objects Classes and Modules,  Next: XML tools,  Prev: Types,  Up: Top

18 Object, Classes and Modules
******************************

Kawa provides various ways to define, create, and access Java objects.
Here are the currently supported features.

   The Kawa module system is based on the features of the Java class
system.

* Menu:

* Defining new classes::
* Anonymous classes::
* Enumerations::          Enumeration types
* Annotations::
* Module classes::        Modules and how they are compiled to classes
* Importing::             Importing from a library
* Record types::          Defining Record Types
* Dynamic records::       Creating New Record Types On-the-fly
* Method operations::     Calling Java methods from Scheme
* Allocating objects::
* Field operations::      Accessing fields of Java objects
* Mangling::              Mapping Scheme names to Java names
* Scheme types in Java::
* Array operations::      Using Java arrays
* Loading Java functions into Scheme::
* Evaluating Scheme expressions from Java::

 -- Syntax: this
     Returns the "this object" - the current instance of the current
     class.  The current implementation is incomplete, not robust, and
     not well defined.  However, it will have to do for now.  Note:
     "â€˜thisâ€™" is a macro, not a variable, so you have to write it using
     parentheses: â€˜(this)â€™.  A planned extension will allow an optional
     class specifier (needed for nested clases).


File: kawa.info,  Node: Defining new classes,  Next: Anonymous classes,  Up: Objects Classes and Modules

18.1 Defining new classes
=========================

Kawa provides various mechanisms for defining new classes.  The
â€˜define-classâ€™ and â€˜define-simple-classâ€™ forms will usually be the
preferred mechanisms.  They have basically the same syntax, but have a
couple of differences.  â€˜define-classâ€™ allows multiple inheritance as
well as true nested (first-class) class objects.  However, the
implementation is more complex: code using it is slightly slower, and
the mapping to Java classes is a little less obvious.  (Each Scheme
class is implemented as a pair of an interface and an implementation
class.)  A class defined by â€˜define-simple-classâ€™ is slightly more
efficient, and it is easier to access it from Java code.

   The syntax of â€˜define-classâ€™ are mostly compatible with that in the
Guile and Stk dialects of Scheme.

 -- Syntax: define-class CLASS-NAME â€˜(â€™supers ...â€˜)â€™
          (ANNOTATION|OPTION-PAIR)^* FIELD-OR-METHOD-DECL ...
 -- Syntax: define-simple-class CLASS-NAME â€˜(â€™supers ...â€˜)â€™
          (ANNOTATION|OPTION-PAIR)^* FIELD-OR-METHOD-DECL ...

     Defines a new class named CLASS-NAME.  If â€˜define-simple-classâ€™ is
     used, creates a normal Java class named CLASS-NAME in the current
     package.  (If CLASS-NAME has the form â€˜<xyz>â€™ the Java
     implementation type is named â€˜xyzâ€™.)  For â€˜define-classâ€™ the
     implementation is unspecified.  In most cases, the compiler creates
     a class pair, consisting of a Java interface and a Java
     implementation class.
     CLASS-NAME ::= IDENTIFIER
     OPTION-PAIR ::= OPTION-KEYWORD OPTION-VALUE
     FIELD-OR-METHOD-DECL ::= FIELD-DECL | METHOD-DECL

18.1.1 General class properties
-------------------------------

The class inherits from the classes and interfaces listed in SUPERS.
This is a list of names of classes that are in scope (perhaps imported
using â€˜requireâ€™), or names for existing classes or interfaces optionally
surrounded by â€˜<>â€™, such as â€˜<gnu.lists.Sequence>â€™.  If
â€˜define-simple-classâ€™ is used, at most one of these may be the name of a
normal Java class or classes defined using â€˜define-simple-classâ€™; the
rest must be interfaces or classes defined using â€˜define-classâ€™.  If
â€˜define-classâ€™ is used, _all_ of the classes listed in SUPERS should be
interfaces or classes defined using â€˜define-classâ€™.

â€˜interface:â€™ MAKE-INTERFACE
     Specifies whether Kawa generates a Java class, interface, or both.
     If MAKE-INTERFACE is â€˜#tâ€™, then a Java interface is generated.  In
     that case all the supertypes must be interfaces, and all the
     declared methods must be abstract.  If MAKE-INTERFACE is â€˜#fâ€™, then
     a Java class is generated.  If â€˜interface:â€™ is unspecified, the
     default is â€˜#fâ€™ for â€˜define-simple-classâ€™.  For â€˜define-classâ€™ the
     default is to generate an interface, and in addition (if needed) a
     helper class that implements the interface.  (In that case any
     non-abstract methods are compiled to static methods.  The methods
     that implement the interface are just wrapper methods that call the
     real static methods.  This allows Kawa to implement true multiple
     inheritance.)

â€˜access:â€™ KIND
     Specifies the Java access permission on the class.  Can be one of
     â€˜'publicâ€™ (which is the default in Kawa), â€˜'packageâ€™ (which the
     default "unnamed" permission in Java code), â€˜'protectedâ€™,
     â€˜'privateâ€™, â€˜'volatileâ€™, or â€˜'transientâ€™.  Can also be used to
     specify â€˜finalâ€™, â€˜abstractâ€™, or â€˜enumâ€™, as in Java.  (You donâ€™t
     need to explicitly specify the class is â€˜abstractâ€™ if any
     METHOD-BODY is â€˜#!abstractâ€™, or you specify â€˜interface: #tâ€™.)  The
     KIND can also be a list, as for example:
          access: '(protected volatile)

â€˜class-name:â€™ â€˜"â€™CNAMEâ€˜"â€™
     Specifies the Java name of the created class.  The NAME specified
     after â€˜define-classâ€™ or â€˜define-simple-classâ€™ is the _Scheme name_,
     i.e.  the name of a Scheme variable that is bound to the class.
     The Java name is by default derived from the Scheme name, but you
     can override the default with a â€˜class-name:â€™ specifier.  If the
     CNAME has no periods, then it is a name in the package of the main
     (module) class.  If the CNAME starts with a period, then you get a
     class nested within the module class.  In this case the actual
     class name is MODULECLASSâ€˜$â€™RNAME, where RNAME is CNAME without the
     initial period.  To force a class in the top-level (unnamed)
     package (something not recommended) write a period at the end of
     the CNAME.

18.1.2 Declaring fields
-----------------------

     FIELD-DECL ::= â€˜(â€™FIELD-NAME (ANNOTATION | OPT-TYPE-SPECIFIER | FIELD-OPTION)*â€˜)â€™
     FIELD-NAME ::= IDENTIFIER
     FIELD-OPTION ::= KEYWORD EXPRESSION

   As a matter of style the following order is suggested, though this
not enforced:
     â€˜(â€™FIELD-NAME ANNOTATION* OPT-TYPE-SPECIFIER FIELD-OPTION*â€˜)â€™

   Each FIELD-DECL declares a instance "slot" (field) with the given
FIELD-NAME.  By default it is publicly visible, but you can specify a
different visiblity with the â€˜access:â€™ specifier.  The following
FIELD-OPTION KEYWORDs are implemented:
â€˜type:â€™ TYPE
     Specifies that TYPE is the type of (the values of) the field.
     Equivalent to â€˜:: TYPEâ€™.
â€˜allocation:â€™ KIND
     If KIND is â€˜'classâ€™ or â€˜'staticâ€™ a single slot is shared between
     all instances of the class (and its sub-classes).  Not yet
     implemented for â€˜define-classâ€™, only for â€˜define-simple-classâ€™.  In
     Java terms this is a â€˜staticâ€™ field.

     If KIND is â€˜'instanceâ€™ then each instance has a separate value
     "slot", and they are not shared.  In Java terms, this is a
     non-â€˜staticâ€™ field.  This is the default.

â€˜access:â€™ KIND
     Specifies the Java access permission on the field.  Can be one of
     â€˜'privateâ€™, â€˜'protectedâ€™, â€˜'publicâ€™ (which is the default in Kawa),
     or â€˜'packageâ€™ (which the default "unnamed" permission in Java
     code).  Can also be used to specify â€˜volatileâ€™, â€˜transientâ€™,
     â€˜enumâ€™, or â€˜finalâ€™, as in Java, or a quoted list with these
     symbols.
â€˜init:â€™ EXPR
     An expression used to initialize the slot.  The expression is
     evaluated in a scope that includes the field and method names of
     the current class.
â€˜init-form:â€™ EXPR
     An expression used to initialize the slot.  The lexical environment
     of the EXPR is that of the â€˜define-classâ€™; it does _not_ include
     the field and method names of the current class.  or
     â€˜define-simple-classâ€™.
â€˜init-value:â€™ VALUE
     A value expression used to initialize the slot.  For now this is
     synonymous with INIT-FORM:, but that may change (depending on what
     other implementation do), so to be safe only use â€˜init-value:â€™ with
     a literal.
â€˜init-keyword:â€™ â€˜NAME:â€™
     A keyword that that can be used to initialize instance in â€˜makeâ€™
     calls.  For now, this is ignored, and NAME should be the same as
     the fieldâ€™s FIELD-NAME.

   The FIELD-NAME can be left out.  That indicates a "dummy slot", which
is useful for initialization not tied to a specific field.  In Java
terms this is an instance or static initializer, i.e., a block of code
executed when a new instance is created or the class is loaded.

   In this example, â€˜xâ€™ is the only actual field.  It is first
initialized to 10, but if â€˜(some-condition)â€™ is true then its value is
doubled.
     (define-simple-class <my-class> ()
       (allocation: 'class
        init: (perform-actions-when-the-class-is-initizalized))
       (x init: 10)
       (init: (if (some-condition) (set! x (* x 2)))))

18.1.3 Declaring methods
------------------------

     METHOD-DECL ::= â€˜((â€™METHOD-NAME FORMAL-ARGUMENTSâ€˜)â€™
         (ANNOTATION | OPT-RETURN-TYPE | OPTION-PAIR)^* [DEPRECATED-RETURN-SPECIFIER] METHOD-BODYâ€˜)â€™
     METHOD-NAME ::= IDENTIFIER
     METHOD-BODY ::= BODY | â€˜#!abstractâ€™ | â€˜#!nativeâ€™
     DEPRECATED-RETURN-SPECIFIER ::= IDENTIFIER

   Each METHOD-DECL declares a method, which is by default public and
non-static, and whose name is METHOD-NAME.  (If METHOD-NAME is not a
valid Java method name, it is mapped to something reasonable.  For
example â€˜foo-bar?â€™ is mapped to â€˜isFooBarâ€™.)  The types of the method
arguments can be specified in the FORMAL-ARGUMENTS.  The return type can
be specified by a OPT-RETURN-TYPE, DEPRECATED-RETURN-SPECIFIER, or is
otherwise the type of the BODY.  Currently, the FORMAL-ARGUMENTS cannot
contain optional, rest, or keyword parameters.  (The plan is to allow
optional parameters, implemented using multiple overloaded methods.)

   A METHOD-DECL in a â€˜define-simple-classâ€™ can have the following
OPTION-KEYWORDs:
â€˜access:â€™ KIND
     Specifies the Java access permission on the method.  Can be one of
     â€˜'privateâ€™, â€˜'protectedâ€™, â€˜'publicâ€™, or â€˜'packageâ€™.  Can also be
     â€˜'synchronizedâ€™, â€˜'finalâ€™, â€˜'strictfpâ€™, or a quoted list.
â€˜allocation:â€™ KIND
     If KIND is â€˜'classâ€™ or â€˜'staticâ€™ creates a static method.
â€˜throws:â€™ ( EXCEPTION-CLASS-NAME ... )
     Specifies a list of checked exception that the method may throw.
     Equivalent to a â€˜throwsâ€™ specification in Java code.  For example:
          (define-simple-class T
            (prefix)
            ((lookup name) throws: (java.io.FileNotFoundException)
             (make java.io.FileReader (string-append prefix name))))

   The scope of the BODY of a method includes the FIELD-DECLs and
FIELD-DECLs of the body, including those inherited from superclasses and
implemented interfaces.

   If the METHOD-BODY is the special form â€˜#!abstractâ€™, then the method
is abstract.  This means the method must be overridden in a subclass,
and youâ€™re not allowed to create an instance of the enclosing class.

     (define-simple-class Searchable () interface: #t
       ((search value) :: boolean #!abstract))

   If the METHOD-BODY is the special form â€˜#!nativeâ€™, then the method is
native, implemented using JNI
(http://en.wikipedia.org/wiki/Java_Native_Interface).

   The special METHOD-NAME â€˜*init*â€™ can be used to name a non-default
constructor (only if MAKE-INTERFACE discussed above is â€˜#fâ€™).  It can be
used to initialize a freshly-allocated instance using passed-in
parameters.  You can call a superclass or a sibling constructor using
the â€˜invoke-specialâ€™ special function.  (This is general but admittedly
a bit verbose; a more compact form may be added in the future.)  See the
example below.

18.1.4 Example
--------------

In the following example we define a simple class â€˜2d-vectorâ€™ and a
class â€˜3d-vectorâ€™ that extends it.  (This is for illustration only -
defining 3-dimensional points as an extension of 2-dimensional points
does not really make sense.)

     (define-simple-class 2d-vector ()
       (x ::double init-keyword: x:)
       ;; Alternative type-specification syntax.
       (y type: double init-keyword: y:)
       (zero-2d :: 2d-vector allocation: 'static
        init-value: (2d-vector 0))
       ;; An object initializer (constructor) method.
       ((*init* (x0 ::double) (y0 ::double))
        (set! x x0)
        (set! y y0))
       ((*init* (xy0 ::double))
        ;; Call above 2-argument constructor.
        (invoke-special 2d-vector (this) '*init* xy0 xy0))
       ;; Need a default constructor as well.
       ((*init*) #!void)
       ((add (other ::2d-vector)) ::2d-vector
        ;; Kawa compiles this using primitive Java types!
        (2d-vector
          x: (+ x other:x)
          y: (+ y other:y)))
       ((scale (factor ::double)) ::2d-vector
        (2d-vector x: (* factor x) y: (* factor y))))

     (define-simple-class 3d-vector (2d-vector)
       (z type: double init-value: 0.0 init-keyword: z:)
       ;; A constructor which calls the superclass constructor.
       ((*init* (x0 ::double) (y0 ::double) (z0 ::double))
        (invoke-special 2d-vector (this) '*init* x0 y0)
        (set! z z0))
       ;; Need a default constructor.
       ((*init*) #!void)
       ((scale (factor ::double)) ::2d-vector
        ;; Note we cannot override the return type to 3d-vector
        ;; because Kawa doesn't yet support covariant return types.
        (3d-vector
          x: (* factor x)
          y: (* factor (this):y) ;; Alternative syntax.
          z: (* factor z))))

   Note we define both explicit non-default constructor methods, and we
associate fields with keywords, so they can be named when allocating an
object.  Using keywords requires a default constructor, and since having
non-default constructors suppresses the implicit default constructor we
have to explicitly define it.  Using both styles of constructors is
rather redundant, though.


File: kawa.info,  Node: Anonymous classes,  Next: Enumerations,  Prev: Defining new classes,  Up: Objects Classes and Modules

18.2 Anonymous classes
======================

 -- Syntax: object â€˜(â€™supers ...â€˜)â€™ field-or-method-decl ...
     Returns a new instance of an anonymous (inner) class.  The syntax
     is similar to â€˜define-classâ€™.
          OBJECT-FIELD-OR-METHOD-DECL ::= OBJECT-FIELD-DECL | METHOD-DECL
          OBJECT-FIELD-DECL ::= â€˜(â€™FIELD-NAME (ANNOTATION | OPT-TYPE-SPECIFIER | FIELD-OPTION)*  [OBJECT-INIT] â€˜)â€™
          OBJECT-INIT ::= EXPRESSION

     Returns a new instance of a unique (anonymous) class.  The class
     inherits from the list of SUPERS, where at most one of the elements
     should be the base class being extended from, and the rest are
     interfaces.

     This is roughly equivalent to:
          (begin
            (define-simple-class HNAME (SUPERS ...) FIELD-OR-METHOD-DECL ...)
            (make HNAME))

     A FIELD-DECL is as for â€˜define-classâ€™, except that we also allow an
     abbreviated syntax.  Each FIELD-DECL declares a public instance
     field.  If OBJECT-FINIT is given, it is an expression whose value
     becomes the initial value of the field.  The OBJECT-INIT is
     evaluated at the same time as the â€˜objectâ€™ expression is evaluated,
     in a scope where all the FIELD-NAMEs are visible.

     A METHOD-DECL is as for â€˜define-classâ€™.

18.2.1 Lambda as shorthand for anonymous class
----------------------------------------------

An anonymous class is commonly used in the Java platform where a
function language would use a lambda expression.  Examples are call-back
handlers, events handlers, and â€˜runâ€™ methods.  In these cases Kawa lets
you use a lambda expression as a short-hand for an anonymous class.  For
example:
     (button:addActionListener
       (lambda (e) (do-something)))
   is equivalent to:
     (button:addActionListener
       (object (java.awt.event.ActionListener)
         ((actionPerformed (e ::java.awt.event.ActionEvent))::void
          (do-something))))
   This is possible when the required type is an interface or abstract
class with a Single (exactly one) Abstract Methods.  Such a class is
sometypes called a "SAM-type", and the conversion from a lambda
expression to an anonymous class is sometimes called "SAM-conversion".

   Note that Kawa can also infer the parameter and return types of a
method that overrides a method in a super-class.


File: kawa.info,  Node: Enumerations,  Next: Annotations,  Prev: Anonymous classes,  Up: Objects Classes and Modules

18.3 Enumeration types
======================

An enumeration type is a set of named atomic enumeration values that are
distinct from other values.  You define the type using â€˜define-enumâ€™,
and you reference enumeration values using colon notation:
     (define-enum colors (red blue green))
     (define favorite-color colors:green)
   Displaying an enum just prints the enum name, but readable output
using â€˜writeâ€™ (or the â€˜~sâ€™ â€˜formatâ€™ specifier) prepends the type name:
     (format "~a" favorite-color) â‡’ "green"
     (format "~s" favorite-color) â‡’ "colors:green"
   The static â€˜valuesâ€™ method returns a Java array of the enumeration
values, in declaration order, while â€˜ordinalâ€™ yields the index of an
enumeration value:
     (colors:values) â‡’ [red blue green]
     ((colors:values) 1) â‡’ blue
     (favorite-color:ordinal) â‡’ 2
   If you invoke the enumeration type as a function, it will map the
name (as a string) to the corresponding value.  (This uses the â€˜valueOfâ€™
method.)
     (colors "red") â‡’ red
     (colors "RED") â‡’ throws IllegalArgumentException
     (eq? favorite-color (colors:valueOf "green")) â‡’ #t

   Kawa enumerations are based on Java enumerations.  Thus the above is
similar to a Java5 â€˜enumâ€™ declaration, and the type â€˜colorsâ€™ above
extends â€˜java.lang.Enumâ€™.

 -- Syntax: define-enum enum-type-name OPTION-PAIR... â€˜(â€™enum-value-name
          ...â€˜)â€™ FIELD-OR-METHOD-DECL...
     This declares a new enumeration type ENUM-TYPE-NAME, whose
     enumerations values are the ENUM-VALUE-NAME list.  You can specify
     extra options and members using OPTION-PAIR and
     FIELD-OR-METHOD-DECL, which are as in â€˜define-simple-classâ€™.  (The
     DEFINE-ENUM syntax is similar to a â€˜define-simple-classâ€™ that
     extends â€˜java.lang.Enumâ€™.)

   (Note that R6RS has a separate Enumerations library â€˜(rnrs enum)â€™.
Unfortunately, this is not compatible with standard Java enums.  R6RS
enums are simple symbols, which means you cannot distinguish two enum
values from different enumeration types if they have the same value, nor
from a vanilla symbol.  That makes them less useful.)


File: kawa.info,  Node: Annotations,  Next: Module classes,  Prev: Enumerations,  Up: Objects Classes and Modules

18.4 Annotations of declarations
================================

The Java platform lets you associate with each declaration zero or more
annotations
(http://download.oracle.com/javase/1.5.0/docs/guide/language/annotations.html).
They provide an extensible mechanism to associate properties with
declarations.  Kawa support for annotations is not complete (the most
important functionality missing is being able to declare annotation
types), but is fairly functional.  Here is a simple example illustrating
use of JAXB annotations (http://jcp.org/en/jsr/detail?id=222): an
â€˜XmlRootElementâ€™ annotation on a class, and an â€˜XmlElementâ€™ annotation
on a field:
     (define-alias XmlRootElement javax.xml.bind.annotation.XmlRootElement)
     (define-alias XmlElement javax.xml.bind.annotation.XmlElement)
     (define-simple-class Bib ( ) (@XmlRootElement name: "bib")
       (books (@XmlElement name: "book" type: Book) ::java.util.ArrayList))
     (define-simple-class Book () ...)

   This tutorial
(http://per.bothner.com/blog/2011/Using-JAXB-annotations) explains the
JAXB example in depth.

   Here is the syntax:
     ANNOTATION ::= â€˜(@â€™ANNOTATION-TYPENAME ANNOTATIONS-ELEMENT-VALUESâ€˜)â€™
     ANNOTATIONS-ELEMENT-VALUES ::= ANNOTATION-ELEMENT-VALUE
       | ANNOTATION-ELEMENT-PAIR ...
     ANNOTATION-ELEMENT-PAIR ::= KEYWORD ANNOTATION-ELEMENT-VALUE
     ANNOTATION-ELEMENT-VALUE ::= EXPRESSION
     ANNOTATION-TYPENAME ::= EXPRESSION

   An ANNOTATIONS-ELEMENT-VALUES consisting of just a single
ANNOTATION-ELEMENT-VALUE is equivalent to an ANNOTATION-ELEMENT-PAIR
with a â€˜value:â€™ keyword.

   Each KEYWORD must correspond to the name of an element (a
zero-argument method) in the annotation type.  The corresponding
ANNOTATION-ELEMENT-VALUE must be compatible with the element type
(return type of the method) of the annotation type.

   Allowed element types are of the following kinds:
   â€¢ Primitive types, where the ANNOTATION-ELEMENT-VALUE must be number
     or boolean coercible to the element type.
   â€¢ Strings, where the ANNOTATION-ELEMENT-VALUE is normally a string
     literal.
   â€¢ Classes, where the ANNOTATION-ELEMENT-VALUE is normally a
     classname.
   â€¢ Enumeration types.  The value usually has the form
     â€˜CLASSNAME:ENUMFIELDNAMEâ€™.
   â€¢ Nested annotation types, where the ANNOTATION-ELEMENT-VALUE must be
     a compatible ANNOTATION value.
   â€¢ An array of one of the allowable types.  An array constructor
     expression works, but using the square bracket syntax is
     recommended.

   Annotations are usually used in declarations, where they are required
to be â€œconstant-foldedâ€ to compile-time constant annotation values.
This is so they can be written to class files.  However, in other
contexts an annotation can be used as an expression with general
sub-expressions evaluated at run-time:
     (define bk-name "book")
     (define be (@XmlElement name: bk-name type: Book))
     (be:name) â‡’ "book"
   (This may have limited usefulness: There are some bugs, including
lack of support for default values for annotation elements.  These bugs
can be fixed if someone reports a need for runtime construction of
annotation values.)


File: kawa.info,  Node: Module classes,  Next: Importing,  Prev: Annotations,  Up: Objects Classes and Modules

18.5 Modules and how they are compiled to classes
=================================================

Modules provide a way to organize Scheme into reusable parts with
explicitly defined interfaces to the rest of the program.  A "module" is
a set of definitions that the module "exports", as well as some
"actions" (expressions evaluated for their side effect).  The top-level
forms in a Scheme source file compile a module; the source file is the
"module source".  When Kawa compiles the module source, the result is
the "module class".  Each exported definition is translated to a public
field in the module class.

   You can declare a class using â€˜define-simple-classâ€™ with the same
name as the module class, for example the following in a file named
â€˜foo.scmâ€™:
     (define-simple-class foo ...)
   In this case the defined class will serve dual-purpose as the module
class.

18.5.1 Name visibility
----------------------

The definitions that a module exports are accessible to other modules.
These are the "public" definitions, to use Java terminology.  By
default, all the identifiers declared at the top-level of a module are
exported, except those defined using â€˜define-privateâ€™.  (If compiling
with the â€˜--mainâ€™ flag, then by default no identifiers are exported.)
However, a major purpose of using modules is to control the set of names
exported.  One reason is to reduce the chance of accidental name
conflicts between separately developed modules.  An even more important
reason is to enforce an interface: Client modules should only use the
names that are part of a documented interface, and should not use
internal implementation procedures (since those may change).

   If there is a â€˜module-exportâ€™ (or â€˜exportâ€™) declaration in the
module, then only those names listed are exported.  There can be more
than one â€˜module-exportâ€™, and they can be anywhere in the Scheme file.
The recommended style has a single â€˜module-exportâ€™ near the beginning of
the file.

 -- Syntax: module-export EXPORT-SPEC^*
 -- Syntax: export EXPORT-SPEC^*
     The forms â€˜exportâ€™ and â€˜module-exportâ€™ are equivalent.  (The older
     Kawa name is â€˜module-exportâ€™; â€˜exportâ€™ comes from R7RS.) Either
     form specifies a list of identifiers which can be made visible to
     other libraries or programs.
          EXPORT-SPEC ::= IDENTIFIER
            | â€˜(renameâ€™ IDENTIFIER_1 IDENTIFIER_2â€˜)â€™
     In the former variant, an IDENTIFIER names a single binding defined
     within or imported into the library, where the external name for
     the export is the same as the name of the binding within the
     library.  A â€˜renameâ€™ spec exports the binding defined within or
     imported into the library and named by IDENTIFIER_1, using
     IDENTIFIER_2 as the external name.

     Note that it is an error if there is no definition for IDENTIFIER
     (or IDENTIFIER_1) in the current module, or if it is defined using
     â€˜define-privateâ€™.

     As a matter of style, â€˜exportâ€™ or â€˜module-exportâ€™ should appear
     after â€˜module-nameâ€™ but _before_ other commands (including â€˜importâ€™
     or â€˜requireâ€™).  (This is a requirement if there are any cycles.)

   In this module, â€˜factâ€™ is public and â€˜workerâ€™ is private:
     (module-export fact)
     (define (worker x) ...)
     (define (fact x) ...)

   Alternatively, you can write:
     (define-private (worker x) ...)
     (define (fact x) ...)

18.5.2 R7RS explicit library modules
------------------------------------

A R7RS â€˜define-libraryâ€™ form is another way to create a module.  The
R7RS term "library" is roughly the same as a Kawa module.  In Kawa, each
source file is a *note "implicit module": implicit library, which may
contain zero or more explicit sub-modules (in the form of
â€˜define-libraryâ€™) optionally followed by the definitions and expressions
of the implicit (file-level) module.

 -- Syntax: define-library LIBRARY-NAME LIBRARY-DECLARATION^*
     LIBRARY-NAME ::= â€˜(â€™ LIBRARY-NAME-PARTS â€˜)â€™
     LIBRARY-NAME-PARTS ::= IDENTIFIER^+

   A LIBRARY-NAME is a list whose members are identifiers and exact
non-negative integers.  It is used to identify the library uniquely when
importing from other programs or libraries.  Libraries whose first
identifier is â€˜schemeâ€™ are reserved for use by the R7RS report and
future versions of that report.  Libraries whose first identifier is
â€˜srfiâ€™ are reserved for libraries implementing Scheme Requests for
Implementation (http://srfi.schemer.org/).  It is inadvisable, but not
an error, for identifiers in library names to contain any of the
characters â€˜|â€™ â€˜\â€™ â€˜?â€™  â€˜*â€™ â€˜<â€™ â€˜"â€™ â€˜:â€™ â€˜>â€™ â€˜+â€™ â€˜[â€™ â€˜]â€™ â€˜/â€™ â€˜.â€™ or
control characters after escapes are expanded.

   See *note module-name:: for how a LIBRARY-NAME is mapped to a class
name.

     LIBRARY-DECLARATION ::=
       EXPORT-DECLARATION
       | IMPORT-DECLARATION
       | â€˜(beginâ€™ STATEMENT^* â€˜)â€™
       | â€˜(includeâ€™ FILENAME^+â€˜)â€™
       | â€˜(include-ciâ€™ FILENAME^+â€˜)â€™
       | â€˜(include-library-declarationsâ€™ FILENAME^+â€˜)â€™
       | â€˜(cond-expandâ€™ COND-EXPAND-CLAUSE^* [â€˜(elseâ€™ command-or-definition*â€˜)â€™]â€˜)â€™
       | STATEMENT

   The â€˜beginâ€™, â€˜includeâ€™, and â€˜include-ciâ€™ declarations are used to
specify the body of the library.  They have the same syntax and
semantics as the corresponding expression types.  This form of â€˜beginâ€™
is analogous to, but not the same as regular â€˜beginâ€™.  A plain STATEMENT
(which is allowed as a Kawa extension) is also part of the body of the
library, as if it were wrapped in a â€˜beginâ€™).

   The â€˜include-library-declarationsâ€™ declaration is similar to
â€˜includeâ€™ except that the contents of the file are spliced directly into
the current library definition.  This can be used, for example, to share
the same â€˜exportâ€™ declaration among multiple libraries as a simple form
of library interface.

   The â€˜cond-expandâ€™ declaration has the same syntax and semantics as
the â€˜cond-expandâ€™ expression type, except that it expands to spliced-in
library declarations rather than expressions enclosed in â€˜beginâ€™.

   When a library is loaded, its expressions are executed in textual
order.  If a libraryâ€™s definitions are referenced in the expanded form
of a program or library body, then that library must be loaded before
the expanded program or library body is evaluated.  This rule applies
transitively.  If a library is imported by more than one program or
library, it may possibly be loaded additional times.

   Similarly, during the expansion of a library â€˜(foo)â€™, if any syntax
keywords imported from another library â€˜(bar)â€™ are needed to expand the
library, then the library â€˜(bar)â€™ must be expanded and its syntax
definitions evaluated before the expansion of â€˜(foo)â€™.

   Regardless of the number of times that a library is loaded, each
program or library that imports bindings from a library must do so from
a single loading of that library, regardless of the number of import
declarations in which it appears.  That is, â€˜(import (only (foo) aâ€™))
followed by â€˜(import (only (foo) b))â€™ has the same effect as â€˜(import
(only (foo) a b))â€™.

18.5.3 How a module becomes a class
-----------------------------------

If you want to just use a Scheme module as a module (i.e.  â€˜loadâ€™ or
â€˜requireâ€™ it), you donâ€™t care how it gets translated into a module
class.  However, Kawa gives you some control over how this is done, and
you can use a Scheme module to define a class which you can use with
other Java classes.  This style of class definition is an alternative to
â€˜define-classâ€™, which lets you define classes and instances fairly
conveniently.

   The default name of the module class is the main part of the filename
of the Scheme source file (with directories and extensions stripped
off).  That can be overridden by the â€˜-Tâ€™ Kawa command-line flag.  The
package-prefix specified by the â€˜-Pâ€™ flag is prepended to give the
fully-qualified class name.

 -- Syntax: module-name name
 -- Syntax: module-name <name>
 -- Syntax: module-name LIBRARY-NAME
     Sets the name of the generated class, overriding the default.  If
     there is no â€˜.â€™ in the NAME, the package-prefix (specified by the
     â€˜-Pâ€™ Kawa command-line flag) is prepended.

     If the form LIBRARY-NAME is used, then the class name is the result
     of taking each IDENTIFIER in the LIBRARY-NAME-PARTS, *note
     mangling: Mangling. if needed, and concatenating them separated by
     periods.  For example â€˜(org example doc-utils)â€™ becomes
     â€˜org.example.doc$Mnutilsâ€™.

     As a matter of style, â€˜module-nameâ€™ should be the first command in
     a file (after possible comments).  It must appear before a
     â€˜requireâ€™ or â€˜importâ€™, in case of cycles.

   By default, the base class of the generated module class is
unspecified; you cannot count on it being more specific than â€˜Objectâ€™.
However, you can override it with â€˜module-extendsâ€™.

 -- Syntax: module-extends class
     Specifies that the class generated from the immediately surrounding
     module should extend (be a sub-class of) the class â€˜CLASSâ€™.

 -- Syntax: module-implements interface ...
     Specifies that the class generated from the immediately surrounding
     module should implement the interfaces listed.

   Note that the compiler does _not_ currently check that all the
abstract methods requires by the base class or implemented interfaces
are actually provided, and have the correct signatures.  This will
hopefully be fixed, but for now, if you are forgot a method, you will
probably get a verifier error

   For each top-level exported definition the compiler creates a
corresponding public field with a similar (mangled) name.  By default,
there is some indirection: The value of the Scheme variable is not that
of the field itself.  Instead, the field is a â€˜gnu.mapping.Locationâ€™
object, and the value Scheme variable is defined to be the value stored
in the â€˜Locationâ€™.  Howewer, if you specify an explicit type, then the
field will have the specified type, instead of being a â€˜Locationâ€™.  The
indirection using â€˜Locationâ€™ is also avoided if you use
â€˜define-constantâ€™.

   If the Scheme definition defines a procedure (which is not
re-assigned in the module), then the compiler assumes the variable as
bound as a constant procedure.  The compiler generates one or more
methods corresponding to the body of the Scheme procedure.  It also
generates a public field with the same name; the value of the field is
an instance of a subclass of â€˜<gnu.mapping.Procedure>â€™ which when
applied will execute the correct method (depending on the actual
arguments).  The field is used when the procedure used as a value (such
as being passed as an argument to â€˜mapâ€™), but when the compiler is able
to do so, it will generate code to call the correct method directly.

   You can control the signature of the generated method by declaring
the parameter types and the return type of the method.  See the applet
(*note Applet compilation::) example for how this can be done.  If the
procedures has optional parameters, then the compiler will generate
multiple methods, one for each argument list length.  (In rare cases the
default expression may be such that this is not possible, in which case
an "variable argument list" method is generated instead.  This only
happens when there is a nested scope _inside_ the default expression,
which is very contrived.)  If there are â€˜#!keywordâ€™ or â€˜#!restâ€™
arguments, the compiler generate a "variable argument list" method.
This is a method whose last parameter is either an array or a â€˜<list>â€™,
and whose name has â€˜$Vâ€™ appended to indicate the last parameter is a
list.

   Top-leval macros (defined using either â€˜define-syntaxâ€™ or â€˜defmacroâ€™)
create a field whose type is currently a sub-class of
â€˜kawa.lang.Syntaxâ€™; this allows importing modules to detect that the
field is a macro and apply the macro at compile time.

   Unfortunately, the Java class verifier does not allow fields to have
arbitrary names.  Therefore, the name of a field that represents a
Scheme variable is "mangled" (*note Mangling::) into an acceptable Java
name.  The implementation can recover the original name of a field â€˜Xâ€™
as â€˜((gnu.mapping.Named) X).getName()â€™ because all the standard
compiler-generate field types implemented the â€˜Namedâ€™ interface.

18.5.4 Static vs non-static modules
-----------------------------------

There are two kinds of module class: A "static module" is a class (or
gets compiled to a class) all of whose public fields are static, and
that does not have a public constructor.  A JVM can only have a single
global instance of a static module.  An "instance module" has a public
default constructor, and usually has at least one non-static public
field.  There can be multiple instances of an instance module; each
instance is called a "module instance".  However, only a single instance
of a module can be "registered" in an environment, so in most cases
there is only a single instance of instance modules.  Registering an
instance in an environment means creating a binding mapping a magic name
(derived from the class name) to the instance.

   In fact, any Java class class that has the properties of either an
instance module or a static module, is a module, and can be loaded or
imported as such; the class need not have written using Scheme.

   You can control whether a module is compiled to a static or a
non-static class using either a command-line flag to the compiler, or
using the â€˜module-staticâ€™ special form.

â€˜--module-staticâ€™
     If no â€˜module-staticâ€™ is specified, generate a static module (as if
     â€˜(module-static #t)â€™ were specified).  This is (now) the default.
â€˜--module-nonstaticâ€™
â€˜--no-module-staticâ€™
     If no â€˜module-staticâ€™ is specified, generate a non-static module
     (as if â€˜(module-static #f)â€™ were specified).  This used to be the
     default.
â€˜--module-static-runâ€™
     If no â€˜module-staticâ€™ is specified, generate a static module (as if
     â€˜(module-static 'init-run)â€™ were specified).

 -- Syntax: module-static name ...
 -- Syntax: module-static â€˜#tâ€™
 -- Syntax: module-static â€˜#fâ€™
 -- Syntax: module-static â€˜'init-runâ€™
     Control whether the generated fields and methods are static.  If
     â€˜#tâ€™ or â€˜'init-runâ€™ is specified, then the module will be a static
     module, _all_ definitions will be static.  If â€˜'init-runâ€™ is
     specified, in addition the module body is evaluated in the classâ€™s
     static initializer.  (Otherwise, it is run the first time it is
     â€˜requireâ€™â€™d.)  Otherwise, the module is an instance module.
     However, the NAMEs that are explicitly listed will be compiled to
     static fields and methods.  If â€˜#fâ€™ is specified, then all exported
     names will be compiled to non-static (instance) fields and methods.

     By default, if no â€˜module-staticâ€™ is specified:
       1. If there is a â€˜module-extendsâ€™ or â€˜module-implementsâ€™
          declaration, or one of the â€˜--appletâ€™ or â€˜--servletâ€™
          command-line flags was specified, then â€˜(module-static #f)â€™ is
          implied.
       2. If one of the command-line flags â€˜--no-module-staticâ€™,
          â€˜--module-nonstaticâ€™, â€˜--module-staticâ€™, or
          â€˜--module-static-runâ€™ was specified, then the default is â€˜#fâ€™,
          â€˜#fâ€™, â€˜#tâ€™, or â€˜'init-runâ€™, respectively.
       3. Otherwise the default is â€˜(module-static #t)â€™.  (It used to be
          â€˜(module-static #f)â€™ in older Kawa versions.)

     The default is â€˜(module-static #t)â€™.  It usually produces more
     efficient code, and is recommended if a module contains only
     procedure or macro definitions.  However, a static module means
     that all environments in a JVM share the same bindings, which you
     may not want if you use multiple top-level environments.

   The top-level actions of a module will get compiled to a â€˜runâ€™
method.  If there is an explicit â€˜method-extendsâ€™, then the module class
will also automatically implement â€˜java.lang.Runnableâ€™.  (Otherwise, the
class does not implement â€˜Runnableâ€™, since in that case the â€˜runâ€™ method
return an â€˜Objectâ€™ rather than â€˜voidâ€™.  This will likely change.)

18.5.5 Module options
---------------------

Certain compilation options can be be specified _either_ on the
command-line when compiling, or in the module itself.

 -- Syntax: module-compile-options [keyâ€˜:â€™ value] ...
     This sets the value of the â€˜keyâ€™ option to â€˜valueâ€™ for the current
     module (source file).  It takes effect as soon it is seen during
     the first macro-expansion pass, and is active thereafter (unless
     overridden by â€˜with-compile-optionsâ€™).

     The KEY: is one of the supported option names (The ending colon
     makes it a Kawa keyword).  Valid option keys are:

        â€¢ â€˜main:â€™ - Generate an application, with a main method.

        â€¢ â€˜full-tailcalls:â€™ - Use a calling convention that supports
          proper tail recursion.

        â€¢ â€˜warn-undefined-variable:â€™ - Warn if no compiler-visible
          binding for a variable.

        â€¢ â€˜warn-unknown-member:â€™ - Warn if referencing an unknown method
          or field.

        â€¢ â€˜warn-invoke-unknown-method:â€™ - Warn if invoke calls an
          unknown method (subsumed by warn-unknown-member).

        â€¢ â€˜warn-unused:â€™ - Warn if a variable is usused or code never
          executed.

        â€¢ â€˜warn-unreachable:â€™ - Warn if this code can never be executed.
        â€¢ â€˜warn-void-used:â€™ - Warn if an expression depends on the value
          of a void sub-expression (one that never returns a value).
        â€¢ â€˜warn-as-error:â€™ - Treat a compilation warning as if it were
          an error.

     The VALUE must be a literal value: either a boolean (â€˜#tâ€™ or â€˜#fâ€™),
     a number, or a string, depending on the KEY.  (All the options so
     far are boolean options.)

          (module-compile-options warn-undefined-variable: #t)
          ;; This causes a warning message that y is unknown.
          (define (func x) (list x y))

 -- Syntax: with-compile-options [key: value] ... body
     Similar to â€˜module-compile-optionsâ€™, but the option is only active
     within BODY.

     The module option key â€˜main:â€™ has no effect when applied to a
     particular body via the â€˜with-compile-optionsâ€™ syntax.

          (define (func x)
            (with-compile-options warn-invoke-unknown-method: #f
              (invoke x 'size)))


File: kawa.info,  Node: Importing,  Next: Record types,  Prev: Module classes,  Up: Objects Classes and Modules

18.6 Importing from a library
=============================

You can import a module into the current namespace with â€˜importâ€™ or
â€˜requireâ€™.  This adds the exported bindings (or a subset of them) to the
current lexical scope.  It follows that these bindings (which are said
to be imported) are determined at compile-time.

 -- Syntax: import IMPORT-SET^*
     An â€˜importâ€™ declaration provides a way to import identifiers
     exported by a library (module).  Each IMPORT-SET names a set of
     bindings from a library and possibly specifies local names for the
     imported bindings.
          IMPORT-SET ::=
              CLASSNAME
            | LIBRARY-REFERENCE
            | â€˜(libraryâ€™ LIBRARY-REFERENCE â€˜)â€™
            | â€˜(classâ€™ CLASS-PREFIX IMPORT-ONLY-NAME^*â€˜)â€™
            | â€˜(onlyâ€™ IMPORT-SET IMPORT-ONLY-NAME^*â€˜)â€™
            | â€˜(exceptâ€™ IMPORT-SET IDENTIFIER^*â€˜)â€™
            | â€˜(prefixâ€™ IMPORT-SET IDENTIFIER â€˜)â€™
            | â€˜(renameâ€™ IMPORT-SET RENAME-PAIR^*â€˜)â€™
          LIBRARY-REFERENCE ::= â€˜(â€™ LIBRARY-NAME-PARTS [EXPLICIT-SOURCE-NAME]â€˜)â€™
          IMPORT-ONLY-NAME ::= IDENTIFIER|RENAME-PAIR
          EXPLICIT-SOURCE-NAME ::= STRING
          RENAME-PAIR ::= â€˜(â€™ IDENTIFIER_1 IDENTIFIER_2â€˜)â€™

     A LIBRARY-REFERENCE is mapped to a class name by concatenating all
     the identifiers, separated by dots.  For example:
          (import (gnu kawa slib srfi37))
     is equivalent to:
          (import gnu.kawa.slib.srfi37)
     as well as to:
          (require gnu.kawa.slib.srfi37)

     By default, all of an imported libraryâ€™s exported bindings are made
     visible within an importing library using the names given to the
     bindings by the imported library.  The precise set of bindings to
     be imported and the names of those bindings can be adjusted with
     the â€˜onlyâ€™, â€˜exceptâ€™, â€˜prefixâ€™, and â€˜ renameâ€™ forms as described
     below.

        â€¢ An â€˜onlyâ€™ form produces a subset of the bindings from another
          IMPORT-SET, including only the listed IDENTIFIERs.  The
          included IDENTIFIERs must be in the original IMPORT-SET.  If a
          RENAME-PAIR is used, then the â€˜IDENTIFIER_1â€™ must be in the
          original IMPORT-SET, and is renamed to â€˜IDENTIFIER_2â€™.  For
          example:
               (import (only (kawa example) A (B1 B2) C (D1 D2)))
          is equivalent to:
               (import (rename (only (kawa example) A B1 C D1)
                               (B1 B2) (D1 D2)))
          The names â€˜Aâ€™, â€˜B1â€™, â€˜Câ€™, and â€˜D1â€™ must exist in the library
          â€˜(kawa example)â€™.  The bindings are accessible using the names
          â€˜Aâ€™, â€˜B2â€™, â€˜Câ€™, and â€˜D2â€™.

        â€¢ An â€˜exceptâ€™ form produces a subset of the bindings from
          another IMPORT-SET, including all but the listed IDENTIFIERs.
          All of the excluded IDENTIFIERs must be in the original
          IMPORT-SET.

        â€¢ A â€˜prefixâ€™ form adds the IDENTIFIER prefix to each name from
          another IMPORT-SET.

        â€¢ A â€˜renameâ€™ form:
               (rename (IDENTIFIER_1 IDENTIFIER_2) â€¦)
          removes the bindings for â€˜IDENTIFIER_1 â€¦â€™ to form an
          intermediate IMPORT-SET, then adds the bindings back for the
          corresponding â€˜IDENTIFIER_2 â€¦â€™ to form the final IMPORT-SET.
          Each â€˜IDENTIFIER_1â€™ must be in the original IMPORT-SET, each
          IDENTIFIER_2 must not be in the intermediate IMPORT-SET, and
          the IDENTIFIER_2s must be distinct.

     A â€˜classâ€™ form is a convenient way to define abbreviations for
     class names; it may be more convenient than â€˜define-aliasâ€™.  The
     CLASS-PREFIX is concatenated with each IDENTIFIER (with a period in
     between) to produce a classname.  Each IDENTIFIER becomes an alias
     for the class.  For example:
          (import (class java.util Map (HashMap HMap)))
     This defines â€˜Mapâ€™ as an alias for â€˜java.util.Mapâ€™, and â€˜HMapâ€™ as
     an alias for â€˜java.util.HashMapâ€™.  (You can think of the â€˜classâ€™
     form as similar to a â€˜onlyâ€™ form, where the CLASS-PREFIX names a
     special kind of library represented of a Java package, and whose
     exported bindings are the classes in the package.)

     You can combine the â€˜classâ€™ form with â€˜onlyâ€™, â€˜exceptâ€™, â€˜renameâ€™,
     and â€˜prefixâ€™, though only â€˜prefixâ€™ is likely to be useful.  For
     example:
          (import (prefix (class java.lang Long Short) jl-))
     is equivalent to
          (import (class java.lang (Long jl-Long) (Short jl-Short)))
     which is equivalent to:
          (define-private-alias jl-Short java.lang.Short)
          (define-private-alias jl-Long java.lang.Long)

 -- Syntax: require â€˜â€™â€™featureName
 -- Syntax: require classname [EXPLICIT-SOURCE-NAME]
 -- Syntax: require EXPLICIT-SOURCE-NAME]
     Search for a matching module (class), and add the names exported by
     that module to the current set of visible names.  Normally, the
     module is specified using CLASSNAME.

     The form â€˜requireâ€™ has similar functionality as â€˜importâ€™, but with
     a different syntax, and without options like â€˜renameâ€™.

     If a â€˜"SOURCEPATH"â€™ is specified then that is used to locate the
     source file for the module, and if necessary, compile it.

     If a â€˜'FEATURENAMEâ€™ is specified then the FEATURENAME is looked up
     (at compile time) in the "feature table" which yields the
     implementing CLASSNAME.

 -- Syntax: provide â€˜â€™â€™featurename
     Declare that â€˜'FEATURENAMEâ€™ is available.  A following
     â€˜cond-expandâ€™ in this scope will match FEATURENAME.

   Using â€˜requireâ€™ and â€˜provideâ€™ with FEATURENAMEs is similar to the
same-named macros in SLib, Emacs, and Common Lisp.  However, in Kawa
these are not functions, but instead they are syntax forms that are
processed at compile time.  That is why only quoted FEATURENAMEs are
supported.  This is consistent with Kawa emphasis on compilation and
static binding.

   For some examples, you may want to look in the â€˜gnu/kawa/slibâ€™
directory.

18.6.1 Searching for modules
----------------------------

When Kawa sees a â€˜importâ€™ or â€˜requireâ€™ it searches for either a matching
source file or a previously-compiled class with a matching name.

   For â€˜importâ€™ we generate a classname by converting it in the same way
â€˜module-nameâ€™ does: taking each identifier in the LIBRARY-NAME-PARTS,
mangling if needed, and concatenating the parts separated by periods.

   If there is a matching module in any PROGRAM-UNIT that is in the
process of being compiled, we use that.  This may be a file requested to
be compiled with the â€˜-Câ€™ command-line switch, or an extra
LIBRARY-DEFINITION in a file already parsed.  Kawa will attempt to
finish compiling the module and load the class, but if there are
circular dependencies it will use the uncompiled definitions.

   Next Kawa looks for a matching class in the context classpath.
(There is special handling if the library-name starts with â€˜srfiâ€™, and
certain builtin classes will have â€˜kawa.lib.â€™ prepended.)

   Kawa also searches for a matching source file, described below.  It
uses the implicit source name (formed by concatenating the library-name
parts, separated by â€˜"/"â€™), as well as any EXPLICIT-SOURCE-NAME.  The
source file is parsed as a PROGRAM-UNIT.  It is an error the
PROGRAM-UNIT does not declare a library (explicit or implicit) with the
matching name.

   If Kawa finds both a matching source file and a class, it will pick
one based on which is newer.

18.6.2 Searching for source files
---------------------------------

The Java property â€˜kawa.import.pathâ€™ controls how â€˜importâ€™ and â€˜requireâ€™
search for a suitable source file.  Example usage:
     $ kawa -Dkawa.import.path=".:<foo fo>/opt/fo-libs/*.scm:/usr/local/kawa"

   The value of the â€˜kawa.import.pathâ€™ property is a list of path
elements, separated by â€˜":"â€™.  Each path element is combined with either
the explicit source name or the implicit source name to produce a
filename.  If a matching file exists, then we have found a source file.

   If a path element contains a â€˜"*"â€™ then the â€˜"*"â€™ is replaced by the
implicit source name (without an extension).  (Any explicit source name
is ignored in this case.)  For example, for â€˜(import (foo bar))â€™ or
â€˜(require foo.bar)â€™ the implicit source name is â€˜"foo/bar"â€™.  If the
path element is â€˜"/opt/kawa/*.sc"â€™ then the resulting filename is
â€˜"/opt/kawa/foo/bar.sc"â€™.

   If there is no â€˜"*"â€™ in the path element, and there is an explicit
source, then it is appended to the path element (or replaces the path
element if the explicit source is absolute).  Otherwise we use the
implicit source, followed by the default file extension.  (The default
file extension is that of the current source if that is a named file;
otherwise the default for the current language, which is â€˜".scm"â€™ for
Scheme.)

   A path element that starts with a selector of the form
â€˜"<LIBRARY-NAME-PARTS>"â€™ is only applicable if a prefix of the requested
module name matches the LIBRARY-NAME-PARTS.  If there is â€˜"*"â€™ in the
path element, that is replaced by the corresponding rest of the implicit
source name.  For example if importing â€˜(fee fo foo fumâ€™) and the path
element is â€˜"<fee fo>/opt/fo-libs/*.scm"â€™ then the resulting filename is
â€˜"/opt/fo-libs/foo/fum.scm"â€™.  If there is a selector but no â€˜"*"â€™, then
the rest of the path element following the selector is combined with the
explicit or implicit source as if there were no selector (assuming of
course that the selector matches).

   If the resulting filename is relative, then it is resolved relative
to the "current root".  For example the source to a library with the
name â€˜(x y)â€™ that compiles to a class â€˜x.yâ€™ might be a file named
â€˜/a/b/x/y.scmâ€™.  Then the current root would be â€˜/a/b/â€™ - that is the
directory that results from removing the library name suffix from the
file name.

   More generally: assume the current module has N name components.  For
example the name â€˜(x y)â€™ (with the class name â€˜x.yâ€™) has 2 components.
The current root is what you get when you take the current file name
(say â€˜"/a/b/c/d.scm"â€™), and remove everything after the Nâ€™th slash
(â€˜"/"â€™) from the end (say â€˜"c/d.scm"â€™; what remains (e.g.  â€˜"/a/b/"â€™ is
the current root.  (If the current input source is not a named file, use
the value of â€˜(current-path)â€™ with a â€˜"/"â€™ appended.)

   The default search path is â€˜"."â€™ - i.e.  just search relative to the
current root.

18.6.3 Builtin libraries
------------------------

The following libraries are bundled with Kawa:

â€˜(scheme base)â€™
â€˜(scheme case-lambda)â€™
â€˜(scheme char)â€™
â€˜(scheme complex)â€™
â€˜(scheme cxr)â€™
â€˜(scheme cxr)â€™
â€˜(scheme eval)â€™
â€˜(scheme inexact)â€™
â€˜(scheme lazy)â€™
â€˜(scheme load)â€™
â€˜(scheme process-context)â€™
â€˜(scheme read)â€™
â€˜(scheme repl)â€™
â€˜(scheme time)â€™
â€˜(scheme write)â€™
â€˜(scheme r5rs)â€™
     The above are standard libraries as defined by R7RS.
â€˜(rnrs hashtables)â€™
â€˜(rnrs lists)â€™
â€˜(rnrs programs)â€™
â€˜(rnrs sorting)â€™
â€˜(rnrs unicode)â€™
     The above are standard libraries as defined by R6RS.
â€˜(kawa reflect)â€™
     Defines procedures and syntax for acessing Java objects and
     members: â€˜asâ€™ â€˜fieldâ€™ â€˜instance?â€™  â€˜invokeâ€™ â€˜invoke-staticâ€™
     â€˜invoke-specialâ€™ â€˜makeâ€™ â€˜primitive-throwâ€™ â€˜set-field!â€™
     â€˜set-static-field!â€™  â€˜static-fieldâ€™
â€˜(kawa expressions)â€™
â€˜(kawa hashtable)â€™
â€˜(kawa quaternions)â€™
â€˜(kawa rotations)â€™
â€˜(kawa regex)â€™
â€˜(kawa string-cursors)â€™
     Various Kawa libraries add details.
â€˜(kawa base)â€™
     All the bindings by default available to the kawa top-level.

18.6.4 Importing a SRFI library
-------------------------------

Importing a supported SRFI numbered N is conventionally doing using a
â€˜(import (srfi N))â€™ or the older R6RS syntax â€˜(import (srfi :N))â€™ (with
a colon, for historical reasons).  You can also give it a name, as
specified by SRFI 95 (http://srfi.schemers.org/srfi-95/srfi-95.html).
For example, any of these work:
     (import (srfi 95))
     (import (srfi 95 sorting-and-merging))
     (import (srfi :95))
     (import (srfi :95 sorting-and-merging))
   You can also use â€˜(require 'srfi-N)â€™:
     (require 'srfi-95)

18.6.5 Importing from a plain class
-----------------------------------

Note you can import from many classes, even if they werenâ€™t compiled
from a library-definition.  The set of â€˜publicâ€™ fields in a class are
considered as the set of exported definitions, with the names demangled
as needed.

   The module can be static module (all public fields must be static),
or an instance module (it has a public default constructor).

   If an imported definition is a non-static field and if no module
instance for that class has been registered in the current environment,
then a new instance is created and registered (using a "magic"
identifier).  If the module class either inherits from
â€˜gnu.expr.ModuleBodyâ€™ or implements â€˜java.lang.Runnableâ€™ then the
corresponding â€˜runâ€™ method is executed.  (This is done _after_ the
instance is registered so that cycles can be handled.)  These actions
(creating, registering, and running the module instance) are done both
at compile time and at run time, if necessary.

   All the imported fields of the module class are then incorporated in
the current set of local visible names in the current module.  (This is
for both instance and static modules.)  This is done at compile time -
no new bindings are created at run-time (except for the magic binding
used to register the module instance), and the imported bindings are
private to the current module.  References to the imported bindings will
be compiled as field references, using the module instance (except for
static fields).


File: kawa.info,  Node: Record types,  Next: Dynamic records,  Prev: Importing,  Up: Objects Classes and Modules

18.7 Record types
=================

The â€˜define-record-typeâ€™ form can be used for creating new data types,
called record types.  A predicate, constructor, and field accessors and
modifiers are defined for each record type.  The â€˜define-record-typeâ€™
feature is specified by SRFI-9
(http://srfi.schemers.org/srfi-9/srfi-9.html), which is implemented by
many modern Scheme implementations.

 -- Syntax: define-record-type TYPE-NAME (CONSTRUCTOR-NAME FIELD-TAG
          ...) PREDICATE-NAME (FIELD-TAG ACCESSOR-NAME [MODIFIER-NAME])
          ...

     The form â€˜define-record-typeâ€™ is generative: each use creates a new
     record type that is distinct from all existing types, including
     other record types and Schemeâ€™s predefined types.  Record-type
     definitions may only occur at top-level (there are two possible
     semantics for â€˜internalâ€™ record-type definitions, generative and
     nongenerative, and no consensus as to which is better).

     An instance of â€˜define-record-typeâ€™ is equivalent to the following
     definitions:
        â€¢ The TYPE-NAME is bound to a representation of the record type
          itself.
        â€¢ The CONSTRUCTOR-NAME is bound to a procedure that takes as
          many arguments as there are FIELD-TAGs in the
          â€˜(CONSTRUCTOR-NAME ...)â€™ subform and returns a new TYPE-NAME
          record.  Fields whose tags are listed with CONSTRUCTOR-NAME
          have the corresponding argument as their initial value.  The
          initial values of all other fields are unspecified.
        â€¢ The PREDICATE-NAME is a predicate that returns â€˜#tâ€™ when given
          a value returned by CONSTRUCTOR-NAME and â€˜#fâ€™ for everything
          else.
        â€¢ Each ACCESSOR-NAME is a procedure that takes a record of type
          TYPE-NAME and returns the current value of the corresponding
          field.  It is an error to pass an accessor a value which is
          not a record of the appropriate type.
        â€¢ Each MODIFIER-NAME is a procedure that takes a record of type
          TYPE-NAME and a value which becomes the new value of the
          corresponding field.  The result (in Kawa) is the empty value
          â€˜#!voidâ€™.  It is an error to pass a modifier a first argument
          which is not a record of the appropriate type.

     Set!ing the value of any of these identifiers has no effect on the
     behavior of any of their original values.

   Here is an example of how you can define a record type named â€˜pareâ€™
with two fields â€˜xâ€™ and â€˜yâ€™:
     (define-record-type pare
       (kons x y)
       pare?
       (x kar set-kar!)
       (y kdr))

   The above defines â€˜konsâ€™ to be a constructor, â€˜karâ€™ and â€˜kdrâ€™ to be
accessors, â€˜set-kar!â€™ to be a modifier, and â€˜pare?â€™ to be a predicate
for â€˜pareâ€™s.
     (pare? (kons 1 2))        â‡’ #t
     (pare? (cons 1 2))        â‡’ #f
     (kar (kons 1 2))          â‡’ 1
     (kdr (kons 1 2))          â‡’ 2
     (let ((k (kons 1 2)))
       (set-kar! k 3)
       (kar k))                â‡’ 3

   Kawa compiles the record type into a nested class.  If the
â€˜define-record-typeâ€™ appears at module level, the result is a class that
is a member of the module class.  For example if the above â€˜pareâ€™ class
is define in a module â€˜parelibâ€™, then the result is a class named â€˜pareâ€™
with the internal JVM name â€˜parelib$pareâ€™.  The â€˜define-record-typeâ€™ can
appear inside a procedure, in which case the result is an inner class.

   The nested class has a name derived from the TYPE-NAME.  If the
TYPE-NAME is valid Java class name, that becomes the name of the Java
class.  If the TYPE-NAME has the form â€˜<NAME>â€™ (for example â€˜<pare>â€™),
then NAME is used, if possible, for the Java class name.  Otherwise, the
name of the Java class is derived by "mangling" the TYPE-NAME.  In any
case, the package is the same as that of the surrounding module.

   Kawa generates efficient code for the resulting functions, without
needing to use run-time reflection.


File: kawa.info,  Node: Dynamic records,  Next: Method operations,  Prev: Record types,  Up: Objects Classes and Modules

18.8 Creating New Record Types On-the-fly
=========================================

Calling the â€˜make-record-typeâ€™ procedure creates a new record data type
at run-time, without any compile-time support.  It is primarily provided
for compatibility; in most cases it is better to use the
â€˜define-record-typeâ€™ form (*note Record types::).

 -- Procedure: make-record-type type-name field-names
     Returns a "record-type descriptor", a value representing a new data
     type disjoint from all others.  The TYPE-NAME argument must be a
     string, but is only used for debugging purposes (such as the
     printed representation of a record of the new type).  The
     FIELD-NAMES argument is a list of symbols naming the "fields" of a
     record of the new type.  It is an error if the list contains any
     duplicates.

 -- Procedure: record-constructor rtd [field-names]
     Returns a procedure for constructing new members of the type
     represented by RTD.  The returned procedure accepts exactly as many
     arguments as there are symbols in the given list, FIELD-NAMES;
     these are used, in order, as the initial values of those fields in
     a new record, which is returned by the constructor procedure.  The
     values of any fields not named in that list are unspecified.  The
     FIELD-NAMES argument defaults to the list of field names in the
     call to â€˜make-record-typeâ€™ that created the type represented by
     RTD; if the FIELD-NAMES argument is provided, it is an error if it
     contains any duplicates or any symbols not in the default list.

 -- Procedure: record-predicate rtd
     Returns a procedure for testing membership in the type represented
     by RTD.  The returned procedure accepts exactly one argument and
     returns a true value if the argument is a member of the indicated
     record type; it returns a false value otherwise.

 -- Procedure: record-accessor rtd field-name
     Returns a procedure for reading the value of a particular field of
     a member of the type represented by RTD.  The returned procedure
     accepts exactly one argument which must be a record of the
     appropriate type; it returns the current value of the field named
     by the symbol FIELD-NAME in that record.  The symbol FIELD-NAME
     must be a member of the list of field-names in the call to
     â€˜make-record-typeâ€™ that created the type represented by RTD.

 -- Procedure: record-modifier rtd field-name
     Returns a procedure for writing the value of a particular field of
     a member of the type represented by RTD.  The returned procedure
     accepts exactly two arguments: first, a record of the appropriate
     type, and second, an arbitrary Scheme value; it modifies the field
     named by the symbol FIELD-NAME in that record to contain the given
     value.  The returned value of the modifier procedure is
     unspecified.  The symbol FIELD-NAME must be a member of the list of
     field-names in the call to â€˜make-record-typeâ€™ that created the type
     represented by RTD.

 -- Procedure: record? obj
     Returns a true value if OBJ is a record of any type and a false
     value otherwise.

 -- Procedure: record-type-descriptor record
     Returns a record-type descriptor representing the type of the given
     record.  That is, for example, if the returned descriptor were
     passed to â€˜record-predicateâ€™, the resulting predicate would return
     a true value when passed the given record.

 -- Procedure: record-type-name rtd
     Returns the type-name associated with the type represented by rtd.
     The returned value is â€˜eqv?â€™ to the TYPE-NAME argument given in the
     call to â€˜make-record-typeâ€™ that created the type represented by
     RTD.

 -- Procedure: record-type-field-names rtd
     Returns a list of the symbols naming the fields in members of the
     type represented by RTD.  The returned value is â€˜equal?â€™ to the
     field-names argument given in the call to â€˜make-record-typeâ€™ that
     created the type represented by RTD.

   Records are extensions of the class â€˜Recordâ€™.  These procedures use
the Java 1.1 reflection facility.


File: kawa.info,  Node: Method operations,  Next: Allocating objects,  Prev: Dynamic records,  Up: Objects Classes and Modules

18.9 Calling Java methods from Scheme
=====================================

You can call a Java method as if it were a Scheme procedure using
various mechanisms.

18.9.1 Calling static methods using colon notation
--------------------------------------------------

The easiest way to invoke a static method is to use *note colon
notation: Colon notation, specifically:
     â€˜(â€™CLASS-EXPRESSIONâ€˜:â€™METHOD-NAME ARGUMENT ...â€˜)â€™

   The CLASS-EXPRESSION can be a class in the current lexical scope,
such as a class defined using â€˜define-simple-classâ€™:
     (define-simple-class MyClass ()
       ((add2 x y) allocation: 'static (+ x y)))
     (MyClass:add2 3 4) â‡’ 7

   Often CLASS-EXPRESSION is a fully-qualified class name:
     (java.lang.Math:sqrt 9.0) â‡’ 3.0

   This is only allowed when the name is of a class that exists and is
accessible both at compile-time and run-time, and the name is not
otherwise lexically bound.

   You can also use a defined alias:
     (define-alias jlMath java.lang.Math)
     (jlMath:sqrt 16.0) â‡’ 4.0

   You can even evaluate CLASS-EXPRESSION at run-time (in which case
Kawa may have to use slower reflection):
     (let ((math java.lang.Math)) math:sqrt 9.0) â‡’ 3.0

   Here â€˜java.lang.Mathâ€™ evaluates to a â€˜java.lang.Classâ€™ instance for
the named class (like Javaâ€™s â€˜java.lang.Class.classâ€™, again assuming the
class exists and is accessible both at compile-time and run-time, and
the name is not otherwise lexically bound.

18.9.2 Calling instance methods using colon notation
----------------------------------------------------

The syntax is:
     â€˜(â€™INSTANCEâ€˜:â€™METHOD-NAME ARGUMENT ...â€˜)â€™
   This invokes the method named METHOD-NAME with the evaluated INSTANCE
as the target object and the evaluated ARGUMENTs as the method
arguments.

   For example:
     ((list 9 8 7):toString) â‡’ "(9 8 7)"
     ([5 6 7]:get 2) â‡’ 7

   This older syntax is also available:
     â€˜(*:â€™METHOD-NAME INSTANCE ARGUMENT ...â€˜)â€™

   For example:
     (*:toString (list 9 8 7))

   You can also name the class explicitly:
     â€˜(â€™CLASS-EXPRESSIONâ€˜:â€™METHOD-NAME INSTANCE ARGUMENT ...â€˜)â€™
   For example:
     (java.util.List:get [5 6 7] 2) â‡’ 7
   Using an explicit class is like coercing the INSTANCE:
     â€˜(*:â€™METHOD-NAME â€˜(as â€™CLASS-EXPRESSION INSTANCE â€˜)â€™ARGUMENT ...â€˜)â€™

   Note that for some special values, including â€˜java.lang.Classâ€™
instances, you canâ€™t use the compact form of *note colon notation: Colon
notation. where the INSTANCE is before the comma:
     (java.lang.Integer:getDeclaredField "MAX_VALUE") â‡’ error
   This is because in this case we look for a static member of
â€˜java.lang.Integerâ€™ (at least as currently defined and implemented),
while we want an instance member of â€˜java.lang.Classâ€™.  In those cases
you can use one of these alternative forms, which all return the same
â€˜java.lang.reflect.Fieldâ€™ result:
     (*:getDeclaredField java.lang.Integer "MAX_VALUE")
     (java.lang.Class:getDeclaredField java.lang.Integer "MAX_VALUE")
     (invoke java.lang.Integer 'getDeclaredField "MAX_VALUE")

18.9.3 Method names
-------------------

The method to invoke is selected using the specified method name and
argments.  If specified name is not a Java name, it is "mangled" (*note
Mangling::) into a valid Java name.  All accessible methods whose names
match are considered.  Methods that match after appending â€˜$Vâ€™ or â€˜$Xâ€™
or â€˜$V$Xâ€™ are also considered.  A â€˜$Vâ€™ suffix matches a variable number
of arguments: any excess arguments are collect into an â€˜gnu.lists.LListâ€™
or a Java array (depending on the final parameter type).  A â€˜$Xâ€™
specifies that the method expects an extra implicit â€˜CallContextâ€™
parameter.  In that case the methodâ€™s result is written to the
â€˜CallContextâ€™, so the method result type must be â€˜voidâ€™.

   (Kawa may compile a procedure with a â€˜#!restâ€™ or keyword args whose
name is â€˜FNâ€™ to a method named â€˜FN$Vâ€™.  It adds an implicit parameter
for the extra arguments.  By default this extra extra parameter is a
Scheme list.  You can specify a Java array type instead, in which case
the method is named â€˜FNâ€™ without the â€˜$Vâ€™, and instead it is marked as a
Java-5 varargs method.  The array element type must be compatible with
all the extra arguments.)

18.9.4 Invoking a method with the â€˜invokeâ€™ function
---------------------------------------------------

If you prefer, you can instead use the following functions.  (There is
also an older deprecated lower-level interface (*note Low-level Method
invocation::.)

 -- Procedure: invoke-static class name args ...
     The CLASS can be a â€˜java.lang.Classâ€™, a â€˜gnu.bytecode.ClassTypeâ€™,
     or a â€˜symbolâ€™ or â€˜stringâ€™ that names a Java class.  The NAME can be
     â€˜symbolâ€™ or â€˜stringâ€™ that names one or more methods in the Java
     class.

     Any accessible methods (static or instance) in the specified CLASS
     (or its super-classes) that match "NAME" or "NAME$V" collectively
     form a generic procedure.  When the procedure is applied to the
     argument list, the most specific applicable method is chosen
     depending on the argument list; that method is then called with the
     given arguments.  Iff the method is an instance method, the first
     actual argument is used as the â€˜thisâ€™ argument.  If there are no
     applicable methods (or no methods at all!), or there is no "best"
     method, â€˜WrongTypeâ€™ is thrown.

     An example:
          (invoke-static java.lang.Thread 'sleep 100)

     The behavior of interpreted code and compiled code is not
     identical, though you should get the same result either way unless
     you have designed the classes rather strangely.  The details will
     be nailed down later, but the basic idea is that the compiler will
     "inline" the â€˜invoke-staticâ€™ call if it can pick a single "best"
     matching method.

 -- Procedure: invoke object name args ...
     The NAME can be â€˜<symbol>â€™ or â€˜<string>â€™ that names one or more
     methods in the Java class.

     Any accessible methods (static or instance) in the specified CLASS
     (or its super-classes) that match "NAME" or "NAME$V" collectively
     form a generic procedure.  When the procedure is applied to the
     argument list, the most specific applicable method is chosen
     depending on the argument list; that method is then called with the
     given arguments.  Iff the method is an instance method, the OBJECT
     is used as the â€˜thisâ€™ argument; otherwise OBJECT is prepended to
     the ARGS list.  If there are no applicable methods (or no methods
     at all!), or there is no "best" method, â€˜WrongTypeâ€™ is thrown.

     The behavior of interpreted code and compiled code is not
     indentical, though you should get the same result either way unless
     you have designed the classes rather strangely.  The details will
     be nailed down later, but the basic idea is that the compiler will
     "inline" the â€˜invoke-staticâ€™ call if it can pick a single "best"
     matching method.

     If the compiler cannot determine the method to call (assuming the
     method name is constant), the compiler has to generate code at
     run-time to find the correct method.  This is much slower, so the
     compiler will print a warning.  To avoid a waning, you can use a
     type declaration, or insert a cast:
          (invoke (as java.util.Date my-date) 'setDate cur-date)
     or
          (let ((my-date ::java.util.Date (calculate-date))
                (cur-date ::int (get-cur-date)))
            (invoke my-date 'setDate cur-date))

 -- Procedure: invoke-special class receiver-object name arg ...
     The CLASS can be a â€˜java.lang.Classâ€™, a â€˜gnu.bytecode.ClassTypeâ€™,
     or a â€˜symbolâ€™ or â€˜stringâ€™ that names a Java class.  The NAME can be
     â€˜symbolâ€™ or â€˜stringâ€™ that names one or more methods in the Java
     class.

     This procedure is very similar to â€˜invokeâ€™ and â€˜invoke-staticâ€™ and
     invokes the specified method, ignoring any methods in subclasses
     that might overide it.  One interesting use is to invoke a method
     in your super-class like the Java language â€˜superâ€™ keyword.

     Any methods in the specified CLASS that match "NAME" or "NAME$V"
     collectively form a generic procedure.  That generic procedure is
     then applied as in â€˜invokeâ€™ using the â€˜receiver-objectâ€™ and the
     arguments (if any).

     The compiler must be able to inline this procedure (because you
     cannot force a specific method to be called using reflection).
     Therefore the CLASS and NAME must resolve at compile-time to a
     specific method.

          (define-simple-class <MyClass> (<java.util.Date>)
            ((get-year) :: <int>
             (+ (invoke-special <java.util.Date> (this) 'get-year)) 1900)
            ((set-year (year :: <int>)) :: <void>
             (invoke-special <java.util.Date> (this) 'set-year (- year 1900))))

 -- Procedure: class-methods class name
     Return a generic function containing those methods of CLASS that
     match the name NAME, in the sense of â€˜invoke-staticâ€™.  Same as:
          (lambda args (apply invoke-static (cons class (cons name args))))

   Some examples using these functions are â€˜vectors.scmâ€™ and
â€˜characters.scmâ€™ the directory â€˜kawa/libâ€™ in the Kawa sources.

18.9.5 Using a namespace prefix
-------------------------------

_This way of invoking a method is deprecated._

   You can use â€˜define-namespaceâ€™ to define an alias for a Java class:
     (define-namespace Int32 "class:java.lang.Integer")
   In this example the name â€˜Int32â€™ is a "namespace alias" for the
namespace whose full name is â€˜"class:java.lang.Integer"â€™.  The full name
should be the 6 characters â€˜"class:"â€™ followed by the fully-qualified
name of a Java class.

   Instead of a VAMESPACE-URI you can use a variable that names a class,
usually of the form â€˜<CLASSNAME>â€™.  The following is equivalent to the
above:
     (define-namespace Int32 <java.lang.Integer>)
   However, there is one important difference: The â€˜<CLASSNAME>â€™ is
first searched in the lexical scope.  It may resolve to a class defined
in the current compilation unit (perhaps defined using
â€˜define-simple-classâ€™), or imported from another module, or an alias
(such as from â€˜define-aliasâ€™).  Only if â€˜<CLASSNAME>â€™ is _not_ found in
the current scope is it tried as the class name CLASSNAME.

   You can name a method using a "qualified name" containing a colon.
The part of the name before the colon is a namespace alias (in this case
â€˜Int32â€™), and the part of the name after the colon is the method name.
For example:
     (Int32:toHexString 255) â‡’ "ff"
   This invokes the static method â€˜toHexStringâ€™ in the Java class
â€˜java.lang.Integerâ€™, passing it the argument â€˜255â€™, and returning the
String â€˜"ff"â€™.

   The general syntax is
     (PREFIX:METHOD-NAME ARG ...)
   This invokes the method named METHOD-NAME in the class corresponding
to PREFIX, and the ARGs are the method arguments.

   You can use the method name â€˜newâ€™ to construct new objects:
     (Int32:new '|255|)
   This is equivalent to the Java expression â€˜new Integer("255")â€™.  You
can also write:
     (Int32:new "255")

   You can also call instance methods using a namespace prefix:
     (Int32:doubleValue (Int32:new "00255"))
   This returns the â€˜doubleâ€™ value â€˜255.0â€™.

   As a shorthand, you can use the name of a Java class instead of a
namespace alias:
     (java.lang.Integer:toHexString 255)
     (java.lang.Object:toString some-value)
   If Kawa sees a qualified name with a prefix that is not defined _and_
that matches the name of a known class, then Kawa will automatically
treat the prefix as a nickname for namespace uri like
â€˜class:java.lang.Integerâ€™.  Both conditions should be true at both
compile-time and run-time.  However, using an explicit
â€˜define-namespaceâ€™ is recommended.

   As a final shorthand you can use an identifier in handle brackets,
such as an existing type alias like â€˜<list>â€™.  The following are all
equivalent:
     (<list>:list3 'a 'b 'c)
   This is equivalent to:
     (define-namespace PREFIX <list>
     (PREFIX:list3 'a 'b 'c)
   for some otherwise-unused PREFIX.


File: kawa.info,  Node: Allocating objects,  Next: Field operations,  Prev: Method operations,  Up: Objects Classes and Modules

18.10 Allocating objects
========================

The recommended way to create an instance of a type T is to â€œcallâ€ T as
if it were a function, with the arguments used to initialize the object.
If â€˜Tâ€™ is a class and â€˜Tâ€™ has a matching constructor, then the arguments
will used for constructor arguments:
     (java.util.StringTokenizer "this/is/a/test" "/")
   (You can think of the type T as being coerced to an
instance-constructor function.)

   If â€˜Tâ€™ is a container or collection type, then typically the
arguments will be used to specify the child or component values.  Many
standard Scheme procedures fit this convention.  For example in Kawa
â€˜listâ€™ and â€˜vectorâ€™ evaluate to types, rather than procedures as in
standard Scheme, but because types can be used as constructor functions
it just works:
     (list 'a (+ 3 4) 'c) â‡’ (a 7 c)
     (vector 'a 'b 'c) â‡’ #(a b c)
   Any class â€˜Tâ€™ that has a default constructor and an â€˜addâ€™ method can
be initialized this way.  Examples are â€˜java.utilâ€™ collection classes,
and â€˜jawa.awtâ€™ and â€˜javax.swingâ€™ containers.
     (java.util.ArrayList 11 22 33) â‡’ [11, 22, 333]
   The above expression is equivalent to:
     (let ((tmp (java.util.ArrayList)))
       (tmp:add 11)
       (tmp:add 22)
       (tmp:add 33)
       tmp)

   Allocating Java arrays (*note Creating-new-Java-arrays::) uses a
similar pattern:
     (int[] 2 3 5 7 11)

   Sometimes you want to set some named property to an initial value.
You can do that using a keyword argument.  For example:
     (javax.swing.JButton text: "Do it!" tool-tip-text: "do it")

   This is equivalent to using "setter methods":
     (let ((tmp (javax.swing.JButton)))
       (tmp:setText "Do it!")
       (tmp:setToolTipText "do it")
       tmp)

   A keyword argument â€˜KEY-NAMEâ€™â€˜:â€™ can can translated to either a
â€˜setKEYNAME:â€™ or a â€˜addKEYNAME:â€™ method.  The latter makes it convenient
to add listeners:

     (javax.swing.JButton
       text: "Do it!"
       action-listener:
        (object (java.awt.event.ActionListener)
          ((actionPerformed e) (do-the-action))))
   This is equivalent to:
     (let ((tmp (javax.swing.JButton)))
       (tmp:setText "Do it!")
       (tmp:addActionListener
         (object (java.awt.event.ActionListener)
           ((actionPerformed e) (do-the-action))))
       tmp)

   Making use of so-called â€œSAM-conversionâ€ (*note SAM-conversion::)
makes it even more convenient:
     (javax.swing.JButton
       text: "Do it!"
       action-listener:
        (lambda (e) (do-the-action)))

   The general case allows for a mix of constructor arguments, property
keywords, and child values:
     CLASS-TYPE CONSTRUCTOR-VALUE... PROPERTY-INITIALIZER... CHILD-VALUE...
     CONSTRUCTOR-VALUE ::= EXPRESSION
     PROPERTY-INITIALIZER ::= KEYWORD EXPRESSION
     CHILD-VALUE ::= EXPRESSION

   First an object is constructed with the CONSTRUCTOR-VALUE arguments
(if any) passed to the object constructor; then named properties (if
any) are used to initialize named properties; and then remaining
arguments are used to add child values.

   There is an ambiguity if there is no PROPERTY-INITIALIZER - we canâ€™t
distinguish between a CONSTRUCTOR-VALUE and a CHILD-VALUE.  In that
case, if there is a matching constructor method, then all of the
arguments are constructor arguments; otherwise, there must a default
constructor, and all of the arguments are CHILD-VALUE arguments.

   There is a trick you can you if you need both CONSTRUCTOR-VALUE and
CHILD-VALUE arguments: separate them with an â€œempty keywordâ€ â€˜||:â€™.
This matches a method named â€˜addâ€™, which means that the next argument
effectively a CHILD-VALUE - as do all the remaining arguments.  Example:
     (let ((vec #(1 2 3)))
       (java.util.ArrayList vec ||: 4 5 6))
       â‡’ [1, 2, 3, 4, 5, 6]

   The compiler rewrites these allocations expression to generated
efficient bytecode, assuming that the â€œfunctionâ€ being applied is a type
known by the compiler.  Most of the above expressions also work if the
type is applied at run-time, in which case Kawa has to use slower
reflection:
     (define iarr int[])
     (apply iarr (list 3 4 5)) â‡’ [3 4 5]
   However â€˜addXXXâ€™ methods and SAM-conversion are currently only
recognized in the case of a class known at compile-time, not at
run-time.

   Here is a working Swing demo illustrating many of these techniques:

     (define-alias JButton javax.swing.JButton)
     (define-simple-class HBox (javax.swing.Box)
       ((*init*) (invoke-special javax.swing.Box (this) '*init* 0)))
     (define-alias JFrame javax.swing.JFrame)
     (define-alias Box javax.swing.Box)

     (define value 0)

     (define txt
       (javax.swing.JLabel
        text: "0"))

     (define (set-value i)
       (set! value i)
       (set! txt:text (number->string i)))

     (define fr
       (JFrame
          title: "Hello!"
          (Box 1#|VERTICAL|# ||:
           (javax.swing.Box:createGlue)
           txt
           (javax.swing.Box:createGlue)
           (HBox
            (JButton ;; uses 1-argument constructor
     	"Decrement" ;; constructor argument
     	tool-tip-text: "decrement"
     	action-listener: (lambda (e) (set-value (- value 1))))
            (javax.swing.Box:createGlue)
            (JButton ;; uses 0-argument constructor
     	text: "Increment"
     	tool-tip-text: "increment"
     	action-listener: (lambda (e) (set-value (+ value 1))))))))
     (fr:setSize 200 100)
     (set! fr:visible #t)

   If you prefer, you can use the older â€˜makeâ€™ special function:

 -- Procedure: make type args ...
     Constructs a new object instance of the specified TYPE, which must
     be either a â€˜java.lang.Classâ€™ or a â€˜<gnu.bytecode.ClassType>â€™.
     Equivalent to:
          TYPE ARGS ...

   Another (semi-deprecated) function is to use the colon notation with
the â€˜newâ€™ pseudo-function.  The following three are all equivalent:
     (java.awt.Point:new x: 4 y: 3)
     (make java.awt.Point: x: 4 y: 3)
     (java.awt.Point x: 4 y: 3)

